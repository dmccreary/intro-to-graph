{
  "faq_version": "1.0",
  "generated_date": "2025-11-18",
  "source_textbook": "Introduction to Graph Databases",
  "total_questions": 90,
  "bloom_distribution": {
    "Remember": 16,
    "Understand": 31,
    "Apply": 21,
    "Analyze": 14,
    "Evaluate": 6,
    "Create": 2
  },
  "category_distribution": {
    "Getting Started": 12,
    "Core Concepts": 18,
    "Technical Details": 16,
    "Common Challenges": 9,
    "Best Practices": 9,
    "Advanced Topics": 10,
    "Additional Topics": 16
  },
  "questions": [
    {
      "id": "faq-001",
      "category": "Getting Started",
      "question": "What is this course about?",
      "answer": "This course provides a comprehensive introduction to graph databases, with a focus on the Labeled Property Graph (LPG) model. You'll learn how graph databases treat relationships as first-class citizens, making them ideal for highly connected data. The curriculum covers query languages like openCypher and GSQL, performance optimization, real-world applications in social networks, fraud detection, supply chain management, and healthcare, plus hands-on experience building graph applications. The 14-week course is designed for undergraduate (junior/senior) or graduate introductory level students.",
      "bloom_level": "Understand",
      "difficulty": "easy",
      "concepts": ["Graph Databases", "Labeled Property Graph", "Course Overview"],
      "keywords": ["course", "overview", "graph databases", "LPG", "curriculum"],
      "source_links": ["docs/course-description.md", "docs/chapters/index.md"],
      "has_example": false,
      "word_count": 86
    },
    {
      "id": "faq-002",
      "category": "Getting Started",
      "question": "Who should take this course?",
      "answer": "This course is designed for undergraduate (junior/senior) or graduate students who have prior coursework in databases or data modeling and basic programming knowledge in languages like Python or JavaScript. It's ideal for students interested in modern data management, AI applications, knowledge representation, or building systems that analyze highly connected information. Professionals working with social networks, recommendation engines, fraud detection, supply chain optimization, or knowledge graphs will find the content immediately applicable.",
      "bloom_level": "Understand",
      "difficulty": "easy",
      "concepts": ["Course Audience", "Prerequisites"],
      "keywords": ["audience", "students", "prerequisites", "professionals"],
      "source_links": ["docs/course-description.md#prerequisites"],
      "has_example": false,
      "word_count": 72
    },
    {
      "id": "faq-003",
      "category": "Getting Started",
      "question": "What prerequisites do I need?",
      "answer": "You should have prior coursework in databases or data modeling (recommended), basic programming knowledge in Python, JavaScript, or a similar language, and familiarity with fundamental data structures like arrays, hash maps, and trees. Experience with SQL is helpful but not required—we'll compare relational and graph approaches throughout the course. No prior graph database experience is needed.",
      "bloom_level": "Remember",
      "difficulty": "easy",
      "concepts": ["Prerequisites", "Data Structures", "Programming"],
      "keywords": ["prerequisites", "requirements", "programming", "data structures"],
      "source_links": ["docs/course-description.md#prerequisites", "docs/chapters/01-intro-graph-thinking-data-modeling/index.md"],
      "has_example": false,
      "word_count": 58
    },
    {
      "id": "faq-004",
      "category": "Getting Started",
      "question": "What is the learning graph?",
      "answer": "The learning graph is a directed acyclic graph (DAG) representing the 200 core concepts in this course and their prerequisite relationships. An edge from concept A to concept B means \"A depends on understanding B first.\" This structure ensures you learn concepts in the optimal order, building on previous knowledge. The graph organizes concepts into 12 taxonomies including Foundation Concepts, Graph Data Model, Query Languages, Performance, Algorithms, and industry applications.",
      "bloom_level": "Understand",
      "difficulty": "easy",
      "concepts": ["Concept Dependency Graphs", "Learning Graph", "Curriculum Design"],
      "keywords": ["learning graph", "concepts", "dependencies", "prerequisites"],
      "source_links": ["docs/learning-graph/learning-graph-vis.md", "docs/glossary.md#concept-dependency-graphs"],
      "has_example": true,
      "word_count": 78
    },
    {
      "id": "faq-005",
      "category": "Core Concepts",
      "question": "What is a graph database?",
      "answer": "A graph database is a database system optimized for storing and querying graph-structured data, where relationships between entities are treated as first-class citizens rather than foreign key references. In a graph database, data is stored as nodes (entities), edges (relationships), and properties (attributes). This structure makes graph databases exponentially faster for relationship-heavy queries compared to relational databases that require expensive join operations. For example, in a social network, people are nodes, friendships are edges, and attributes like name and age are properties. Finding \"friends of friends\" requires one simple traversal in a graph database versus multiple self-joins in a relational database.",
      "bloom_level": "Understand",
      "difficulty": "easy",
      "concepts": ["Graph Databases", "Nodes", "Edges", "Properties"],
      "keywords": ["graph database", "nodes", "edges", "relationships", "first-class"],
      "source_links": ["docs/glossary.md#graph-databases", "docs/chapters/01-intro-graph-thinking-data-modeling/index.md"],
      "has_example": true,
      "word_count": 102
    },
    {
      "id": "faq-006",
      "category": "Core Concepts",
      "question": "What is a Labeled Property Graph (LPG)?",
      "answer": "A Labeled Property Graph is the most popular graph data model, where both nodes and edges can have labels (types) and properties (key-value pairs). For example, a Person node with label \"Person\" might have properties like {name: \"Alice\", age: 30}, connected to a Company node via a WORKS_AT edge with property {since: 2020}. This model combines the flexibility of schema-optional design with the semantic richness of typed entities and relationships. In a product catalog, nodes include Products and Categories (labels), with properties like {name: \"Laptop\", price: 999}, connected by BELONGS_TO edges. Multi-edges allow products to belong to multiple categories.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": ["Labeled Property Graph", "Nodes", "Edges", "Properties", "Labels"],
      "keywords": ["LPG", "labeled property graph", "labels", "properties", "schema"],
      "source_links": ["docs/glossary.md#labeled-property-graph", "docs/chapters/03-labeled-property-graph-model/index.md"],
      "has_example": true,
      "word_count": 111
    },
    {
      "id": "faq-007",
      "category": "Core Concepts",
      "question": "What is index-free adjacency?",
      "answer": "Index-free adjacency is a graph storage architecture where each node directly references its connected neighbors in memory, without requiring index lookups to traverse relationships. This enables constant-time neighbor access regardless of total graph size—finding a node's connections takes the same time in a million-node graph as in a billion-node graph. This is the key performance advantage that makes graph databases fast for multi-hop traversals. For example, in Neo4j, each node stores direct pointers to its relationship records, so traversing from Alice to her friends requires no index lookup—just following the pointer. This makes 5-hop queries (friends-of-friends-of-friends-of-friends-of-friends) practical even in massive graphs.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": ["Index-Free Adjacency", "Constant-Time Neighbor Access", "Traversal"],
      "keywords": ["index-free adjacency", "performance", "constant-time", "traversal"],
      "source_links": ["docs/glossary.md#index-free-adjacency", "docs/chapters/05-performance-metrics-benchmarking/index.md"],
      "has_example": true,
      "word_count": 111
    },
    {
      "id": "faq-008",
      "category": "Core Concepts",
      "question": "Why do graphs outperform relational databases for connected data?",
      "answer": "Graph databases avoid the exponential cost of joins required for multi-hop queries in relational databases. Finding friends-of-friends-of-friends in a relational database requires three self-joins, and query time grows exponentially with each hop. Graph databases use index-free adjacency to traverse edges in constant time per hop, making deep traversals practical. For relationship-heavy queries, graphs can be 1000x faster than relational systems. For example, finding products purchased by friends-of-friends (2 hops) in SQL requires multiple joins and scales poorly. In Cypher: MATCH (me)-[:FRIEND*2]->(:Person)-[:PURCHASED]->(p:Product) RETURN p runs efficiently even on large graphs.",
      "bloom_level": "Analyze",
      "difficulty": "medium",
      "concepts": ["Graph Databases", "RDBMS", "Join Operations", "Traversal Cost", "Performance"],
      "keywords": ["performance", "joins", "traversal", "relational", "faster"],
      "source_links": ["docs/chapters/01-intro-graph-thinking-data-modeling/index.md", "docs/chapters/05-performance-metrics-benchmarking/index.md"],
      "has_example": true,
      "word_count": 111
    },
    {
      "id": "faq-009",
      "category": "Core Concepts",
      "question": "What is graph traversal?",
      "answer": "Graph traversal is the process of following edges from node to node to explore graph structure, find paths, or discover patterns. Traversals can be breadth-first (exploring all neighbors at the current depth before going deeper) or depth-first (exploring as far as possible along each branch before backtracking). Efficient traversal is the core operation that makes graph databases powerful for relationship-heavy queries. For example, finding the shortest path from Alice to Bob in a social network uses breadth-first traversal, exploring Alice's friends, then friends-of-friends, until Bob is found.",
      "bloom_level": "Understand",
      "difficulty": "easy",
      "concepts": ["Traversal", "Breadth-First Search", "Depth-First Search"],
      "keywords": ["traversal", "BFS", "DFS", "paths", "exploration"],
      "source_links": ["docs/glossary.md#traversal", "docs/glossary.md#breadth-first-search"],
      "has_example": true,
      "word_count": 99
    },
    {
      "id": "faq-010",
      "category": "Technical Details",
      "question": "What query languages do graph databases use?",
      "answer": "The three major query languages are openCypher (declarative, ASCII-art syntax, widely adopted in Neo4j, Amazon Neptune, and others), GSQL (TigerGraph's language with map-reduce patterns for distributed processing and accumulators for aggregation), and GQL (emerging ISO standard unifying graph query syntax). Each has strengths: Cypher for readability and community support, GSQL for distributed performance, GQL for standardization and vendor independence. For example, Cypher: MATCH (a:Person)-[:KNOWS]->(b) RETURN b.name finds friends. GSQL uses accumulators for efficient distributed aggregation across partitioned graphs.",
      "bloom_level": "Remember",
      "difficulty": "medium",
      "concepts": ["OpenCypher", "GSQL", "GQL", "Query Languages"],
      "keywords": ["Cypher", "GSQL", "GQL", "query languages", "syntax"],
      "source_links": ["docs/chapters/04-query-languages/index.md", "docs/glossary.md#opencypher"],
      "has_example": true,
      "word_count": 102
    },
    {
      "id": "faq-011",
      "category": "Technical Details",
      "question": "What is Cypher syntax?",
      "answer": "Cypher is a declarative graph query language using ASCII-art patterns to visually represent graph structures. Nodes are represented in parentheses (n), edges in brackets with arrows -->, and properties in braces {key: value}. A typical query has MATCH (find pattern), WHERE (filter conditions), and RETURN (specify results). The visual syntax makes Cypher intuitive and readable. For example: MATCH (alice:Person {name: \"Alice\"})-[:KNOWS]->(friend)-[:LIKES]->(movie:Movie) WHERE movie.year > 2020 RETURN movie.title finds movies liked by Alice's friends released after 2020.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": ["Cypher Syntax", "OpenCypher", "Match Clause", "Pattern Matching"],
      "keywords": ["Cypher", "syntax", "MATCH", "WHERE", "RETURN", "ASCII-art"],
      "source_links": ["docs/glossary.md#cypher-syntax", "docs/chapters/04-query-languages/index.md"],
      "has_example": true,
      "word_count": 105
    },
    {
      "id": "faq-012",
      "category": "Technical Details",
      "question": "What is the shortest path algorithm?",
      "answer": "Shortest path algorithms find the minimum-cost or minimum-hop route between nodes. Dijkstra's algorithm finds shortest paths considering edge weights (like distance or time), while breadth-first search finds minimum hop-count paths in unweighted graphs. Graph databases typically provide built-in shortest path functions optimized for traversal. For example: MATCH path = shortestPath((alice)-[:KNOWS*]-(bob)) RETURN length(path) finds how many friendship hops separate Alice and Bob.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": ["Shortest Path Algorithms", "Pathfinding", "Dijkstra", "BFS"],
      "keywords": ["shortest path", "Dijkstra", "pathfinding", "algorithm"],
      "source_links": ["docs/glossary.md#shortest-path-algorithms", "docs/chapters/06-graph-algorithms/index.md"],
      "has_example": true,
      "word_count": 82
    },
    {
      "id": "faq-013",
      "category": "Technical Details",
      "question": "What is PageRank?",
      "answer": "PageRank is an algorithm calculating node importance based on the quality and quantity of incoming edges, originally developed by Google for web page ranking. Nodes pointed to by many important nodes receive high PageRank scores. In graphs, PageRank identifies influential users, critical infrastructure, or important concepts. For example, in a citation network, papers with high PageRank are frequently cited by other highly-cited papers, identifying seminal works. In social networks, PageRank reveals opinion leaders.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": ["PageRank", "Centrality Measures", "Graph Algorithms"],
      "keywords": ["PageRank", "centrality", "importance", "ranking", "algorithm"],
      "source_links": ["docs/glossary.md#pagerank", "docs/chapters/06-graph-algorithms/index.md"],
      "has_example": true,
      "word_count": 81
    },
    {
      "id": "faq-014",
      "category": "Common Challenges",
      "question": "When should I use a graph database instead of a relational database?",
      "answer": "Choose graph databases when your data is relationship-heavy (entities have many interconnected relationships), queries frequently involve multi-hop traversals (friends-of-friends, recommendation paths, supply chain dependencies), relationships carry significant information (not just foreign keys), or your schema evolves frequently. Use relational databases for simple tabular data with few relationships, standard reporting queries, or when ACID transactions on individual records are critical. For example, use graphs for social networks, fraud detection, knowledge graphs, and supply chains. Use relational for transaction processing, basic reporting, and applications where data naturally fits tables.",
      "bloom_level": "Evaluate",
      "difficulty": "medium",
      "concepts": ["Graph Databases", "RDBMS", "Tradeoff Analysis", "Use Cases"],
      "keywords": ["when to use", "tradeoffs", "relational", "graph", "comparison"],
      "source_links": ["docs/chapters/01-intro-graph-thinking-data-modeling/index.md", "docs/chapters/05-performance-metrics-benchmarking/index.md"],
      "has_example": true,
      "word_count": 106
    },
    {
      "id": "faq-015",
      "category": "Common Challenges",
      "question": "Why is my graph query running slowly?",
      "answer": "Common causes include missing indexes (query scans all nodes instead of using indexed entry point), starting traversal from high-cardinality nodes (traversing from millions of nodes), crossing supernodes (processing millions of edges from one node), or inefficient query structure (unnecessary pattern matching). Check query plans to identify bottlenecks. For example, MATCH (p:Product)-[:PURCHASED_BY]->(c:Customer {email: 'alice@example.com'}) is slow (scans all products). Reverse it: MATCH (c:Customer {email: 'alice@example.com'})<-[:PURCHASED_BY]-(p:Product) is fast (starts from one customer via email index).",
      "bloom_level": "Apply",
      "difficulty": "medium",
      "concepts": ["Query Optimization", "Query Performance", "Indexes", "Query Plans"],
      "keywords": ["slow query", "performance", "optimization", "indexes", "troubleshooting"],
      "source_links": ["docs/glossary.md#query-optimization", "docs/chapters/05-performance-metrics-benchmarking/index.md"],
      "has_example": true,
      "word_count": 107
    },
    {
      "id": "faq-016",
      "category": "Common Challenges",
      "question": "What is a supernode and why is it a problem?",
      "answer": "A supernode is a node with extremely high degree (millions of connections), creating performance bottlenecks because traversing from the supernode requires processing all its edges. Supernodes often indicate modeling anti-patterns—for example, connecting all US customers to a single \"USA\" location node. The solution is redesigning the model to avoid concentration. For example, instead of (Person)-[:LIVES_IN]->(USA) for millions, use hierarchical locations: (Person)-[:LIVES_IN]->(City)-[:IN_STATE]->(State)-[:IN_COUNTRY]->(USA), distributing connections across many City nodes.",
      "bloom_level": "Analyze",
      "difficulty": "medium",
      "concepts": ["Supernodes", "Anti-Patterns", "Performance", "Graph Schema"],
      "keywords": ["supernode", "anti-pattern", "bottleneck", "high degree"],
      "source_links": ["docs/glossary.md#supernodes", "docs/chapters/09-modeling-patterns-data-loading/index.md"],
      "has_example": true,
      "word_count": 95
    },
    {
      "id": "faq-017",
      "category": "Best Practices",
      "question": "What are best practices for graph schema design?",
      "answer": "Model entities as nodes and relationships as edges (not properties). Use semantically meaningful edge types (PURCHASED, KNOWS, MANAGES instead of generic RELATED). Keep properties simple (avoid nested structures). Use labels to categorize nodes (Person, Product, Company). Design for your query patterns—structure should match how you'll traverse. Avoid supernodes by hierarchical modeling. For example, E-commerce schema: (Customer)-[:PLACED]->(Order)-[:CONTAINS]->(Product)-[:IN_CATEGORY]->(Category) models natural domain relationships enabling customer purchase history, product recommendations, and category analytics.",
      "bloom_level": "Apply",
      "difficulty": "medium",
      "concepts": ["Graph Schema", "Schema Design", "Best Practices", "Modeling Patterns"],
      "keywords": ["schema design", "best practices", "modeling", "patterns"],
      "source_links": ["docs/chapters/09-modeling-patterns-data-loading/index.md", "docs/glossary.md#graph-schema"],
      "has_example": true,
      "word_count": 103
    },
    {
      "id": "faq-018",
      "category": "Best Practices",
      "question": "How do I optimize graph query performance?",
      "answer": "Best practices: start queries from specific nodes using indexed properties (not broad patterns); use indexes for entry points; avoid crossing supernodes; limit depth of variable-length paths; push filters early (use WHERE close to MATCH); profile queries to identify bottlenecks; consider query plans when optimizing. Small changes in query structure often yield dramatic performance improvements. For example, add USING INDEX c:Customer(email) to hint the query planner, or restructure to start from low-cardinality nodes first.",
      "bloom_level": "Apply",
      "difficulty": "medium",
      "concepts": ["Query Optimization", "Query Performance", "Best Practices", "Indexes"],
      "keywords": ["optimization", "performance", "best practices", "indexes", "query tuning"],
      "source_links": ["docs/chapters/05-performance-metrics-benchmarking/index.md", "docs/glossary.md#query-optimization"],
      "has_example": true,
      "word_count": 91
    },
    {
      "id": "faq-019",
      "category": "Advanced Topics",
      "question": "What are graph neural networks (GNNs)?",
      "answer": "Graph Neural Networks are deep learning architectures that operate on graph-structured data, learning node representations by aggregating information from neighborhoods. GNNs generalize convolutional neural networks to graphs, enabling tasks like node classification, link prediction, and graph classification. They're used in drug discovery (molecular graphs), social network analysis, and recommendation systems. For example, a GNN predicts whether molecules are toxic by learning from molecular graphs where atoms are nodes and bonds are edges, aggregating chemical properties from neighboring atoms.",
      "bloom_level": "Understand",
      "difficulty": "hard",
      "concepts": ["Graph Neural Networks", "Graph Embeddings", "Machine Learning"],
      "keywords": ["GNN", "neural networks", "machine learning", "deep learning"],
      "source_links": ["docs/glossary.md#graph-neural-networks", "docs/chapters/12-advanced-topics-distributed-systems/index.md"],
      "has_example": true,
      "word_count": 89
    },
    {
      "id": "faq-020",
      "category": "Advanced Topics",
      "question": "How do distributed graph databases work?",
      "answer": "Distributed graph databases partition large graphs across multiple servers using graph partitioning strategies that minimize cross-partition edges. Queries coordinate across partitions, potentially using distributed algorithms and map-reduce patterns. Challenges include maintaining consistency (consistency models), minimizing network communication, and balancing load. TigerGraph and Neo4j Fabric are examples. For example, a billion-edge social network is partitioned across 50 servers using community detection to keep friend groups together, minimizing distributed queries for friend-of-friend operations.",
      "bloom_level": "Understand",
      "difficulty": "hard",
      "concepts": ["Distributed Graph Databases", "Graph Partitioning", "Scalability"],
      "keywords": ["distributed", "partitioning", "scalability", "sharding"],
      "source_links": ["docs/glossary.md#distributed-graph-databases", "docs/chapters/12-advanced-topics-distributed-systems/index.md"],
      "has_example": true,
      "word_count": 90
    }
  ],
  "metadata": {
    "skill_version": "faq-generator v1.0",
    "textbook_url": "https://dmccreary.github.io/intro-to-graph/",
    "learning_graph_concepts": 200,
    "glossary_terms": 200,
    "chapter_count": 12,
    "total_word_count": 111304,
    "content_completeness_score": 95,
    "notes": "This is a representative subset of the 90 total FAQ questions. Full FAQ available at docs/faq.md. JSON includes first 20 questions demonstrating structure and diversity across categories and Bloom's Taxonomy levels."
  }
}
