{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to our website.</p>"},{"location":"checklist/","title":"Site Checklist","text":"<ol> <li>Customize the fields in your mkdocs.yml file</li> <li>Configure Google Analytics to use the right site ID</li> <li>Make sure that your .gitignore file includes the <code>site</code> directory</li> <li>Test the build</li> <li>Make sure the Edit button appears</li> <li>Make sure that code color heightening renders correctly</li> <li>run <code>git config advice.addIgnoredFile false</code></li> </ol>"},{"location":"code-highlight-test/","title":"Code Syntax Color Highlight Test","text":""},{"location":"code-highlight-test/#python","title":"Python","text":"<pre><code>hello_string = \"Hello World!\"\nprint(hello_string)\nx = 1\nif x == 1:\n    # indented four spaces\n    print(\"x is 1.\")\n</code></pre>"},{"location":"contact/","title":"Contact","text":"<p>Please contact me on LinkedIn</p> <p>Thanks! - Dan</p>"},{"location":"course-description/","title":"Introduction to Graph Databases","text":"<p>Credits: 3 Length: 14 Weeks Level: Undergraduate (Junior/Senior) or Graduate Introductory Level Prerequisites:</p> <ul> <li>Prior coursework in databases or data modeling (recommended)</li> <li>Basic programming knowledge (Python, JavaScript, or similar)</li> <li>Familiarity with data structures (arrays, hash maps, trees)</li> </ul>"},{"location":"course-description/#course-overview","title":"Course Overview","text":"<p>This course introduces students to graph databases as powerful tools for representing, querying, and analyzing highly connected information. Students learn why traditional relational databases struggle with modern, relationship-heavy data and how Labeled Property Graph (LPG) databases treat relationships as first-class citizens with relationaship types, attributes, directionality, and semantics.</p> <p>We begin by contrasting the architectural foundations of RDBMS vs. NoSQL systems, explore the design motivations behind graph data models, and introduce the formal elements of LPGs: nodes, edges, properties, labels, and schema options. Students then gain hands-on experience modeling and querying real-world graphs using languages such as openCypher, or GSQL (depending on instructor preference).</p> <p>The course emphasizes building real applications: social networks, recommendation engines, fraud detection pipelines, supply-chain models, knowledge graphs, bill-of-materials (BOM), and healthcare data modeling. Students practice evaluating when to choose graph data models, how to optimize them, how to measure performance, and how to design graph schemas aligned with real business domains.</p> <p>The capstone project involves building an end-to-end graph application using an LPG graph database.</p>"},{"location":"course-description/#sample-outline-14-weeks","title":"Sample Outline (14 Weeks)","text":""},{"location":"course-description/#week-1-introduction-to-graph-thinking","title":"Week 1 \u2013 Introduction to Graph Thinking","text":"<ul> <li>Why data modeling matters in our AI-driven world</li> <li>The importance of world-models</li> <li>Knowledge representation strategy</li> <li>Six major representations of data</li> <li>RDBMS vs. OLAP vs. NoSQL</li> <li>When graphs outperform tables</li> <li>Edges are a first class citizen</li> <li>LPG: The most maintainable information model</li> <li>Case Study: Neo4j</li> <li>Timeline of Graph Database</li> </ul>"},{"location":"course-description/#week-2-nosql-and-the-rise-of-graphs","title":"Week 2 \u2013 NoSQL and the Rise of Graphs","text":"<ul> <li>Key-value, document, wide-column, and graph stores</li> <li>Tradeoff analysis (model precision, flexibility, scaling)</li> <li>Representations of knowledge</li> <li>The Knowledge Triangle</li> <li>Single server graphs</li> <li>Distributed graphs</li> <li>Case Study: TigerGraph</li> </ul>"},{"location":"course-description/#week-3-labeled-property-graph-lpg-information-model","title":"Week 3 \u2013 Labeled Property Graph (LPG) Information Model","text":"<ul> <li>Nodes, edges, labels, properties</li> <li>Representing metadata</li> <li>Open vs. Closed World Models</li> <li>Schema-optional vs. schema-enforced modeling</li> <li>Tools to view graph data models</li> <li>Adding rules to graphs</li> <li>Validating documents</li> <li>Validating graphs</li> </ul>"},{"location":"course-description/#week-4-query-languages-for-graphs","title":"Week 4 \u2013 Query Languages for Graphs","text":"<ul> <li>openCypher</li> <li>GSQL - using the map-reduce pattern on a distributed cluster</li> <li>Accumulators - keeping queries short</li> <li>Path patterns, hops, aggregations</li> <li>GQL - the emerging standard for advanced query languages</li> </ul>"},{"location":"course-description/#week-5-index-free-adjacency-performance","title":"Week 5 \u2013 Index-Free Adjacency &amp; Performance","text":"<ul> <li>Traversal fundamentals</li> <li>Constant-time neighbor access</li> <li>Cost comparison: joins vs. traversals</li> <li>Hop count</li> <li>MicroSim: Chart: Comparing Multi-hop performance on RDBMS vs. Graph</li> <li>Degree of a node</li> <li>Indegree</li> <li>Outdegree</li> <li>Edges per node ratios</li> <li>Indexes</li> <li>Vector indexes</li> <li>Graph metrics</li> <li>Statistical Query Tuning</li> </ul>"},{"location":"course-description/#week-6-benchmarking-techniques","title":"Week 6 \u2013 Benchmarking Techniques","text":"<ul> <li>Why benchmarking is critical to promoting graphs</li> <li>Graph benchmarking is difficult</li> <li>Synthetic benchmarks</li> <li>Single node benchmarks</li> <li>Multi-node benchmarks</li> <li>Predicting the future value of insights</li> <li>LDBC SNB benchmark</li> <li>Graph 500 rankings</li> <li>Measuring graph performance</li> <li>Query latency, throughput, and scalability</li> <li>Case Study - six degrees of separation</li> <li>Case Study - Graph 500 rankings</li> <li>Case Study - Healthcare Operations</li> </ul>"},{"location":"course-description/#week-7-modeling-social-networks-and-language","title":"Week 7 \u2013 Modeling Social Networks and Language","text":"<ul> <li>Friend graphs</li> <li>Modeling human resources</li> <li>Case Study: The Org Chart and Skill Management</li> <li>Diagram: Org Chart Models</li> <li>Influence graphs</li> <li>Modeling with edges as first-class citizens</li> <li>Extending your model</li> <li>Adding discussions</li> <li>Adding natural language language processing</li> <li>Adding products to your graph</li> <li>Adding sentiment to your graph</li> <li>Detecting bad fake accounts</li> <li>Case Study: Assigning Tasks from the Backlog</li> </ul>"},{"location":"course-description/#week-8-knowledge-representation-with-concept-graphs","title":"Week 8 \u2013 Knowledge Representation with Concept Graphs**","text":"<ul> <li>Concept dependency graphs</li> <li>Curriculum graphs</li> <li>Ontology-connected graph structures</li> <li>The Simple Knowledge Organization System (SKOS)</li> <li>Preferred Labels and Alternate Labels</li> <li>The Acronym List</li> <li>The Glossary</li> <li>The Controlled Vocabulary</li> <li>The Taxonomy</li> <li>The Ontology</li> <li>Modeling Enterprise Knowledge</li> <li>Modeling Department Knowledge</li> <li>Modeling Project Knowledge</li> <li>Case Study - Extracting Acton Items from Call Transcripts</li> <li>Modeling Personal Knowledge</li> <li>Notetaking</li> <li>Personal Knowledge Graphs</li> <li>Knowledge Capture</li> <li>Tacit Knowledge and Codifiable Knowledge,</li> <li>Enterprise Knowledge Management</li> </ul>"},{"location":"course-description/#week-9-graph-algorithms","title":"Week 9 - Graph Algorithms","text":"<ul> <li>Search</li> <li>Breath First Search (BFS)</li> <li>Depth First Search (DFS)</li> <li>A-Star (A*)</li> <li>Pathfinding</li> <li>Traveling Salesman</li> <li>PageRank</li> <li>Community detection</li> <li>Graph Neural Networks</li> <li>Data Science toolkits</li> </ul>"},{"location":"course-description/#week-9-graph-modeling-patterns","title":"Week 9 \u2013 Graph Modeling Patterns**","text":"<ul> <li>Subgraphs</li> <li>Supernode vs. anti-pattern nodes</li> <li>Hyperedges, multi-edges</li> <li>Time-based modeling patterns</li> <li>Time Trees</li> <li>Modeling Internet of Things Events</li> <li>Modeling Rules and Decision Trees</li> <li>Bitemporal Graph Models (Advanced Topic)</li> <li>Graph quality metrics</li> </ul>"},{"location":"course-description/#weeks-10-and-11-industry-reference-data-models","title":"Weeks 10 and 11 \u2013 Industry Reference Data Models","text":"<ul> <li>Web storefront graph model</li> <li>Product catalogs</li> <li>Bill-of-Materials (BOM) and complex parts</li> <li>Supply chain modeling</li> <li>Modeling financial transactions</li> <li>Fraud detection graphs</li> <li>Highly Regulated Industries</li> <li>Anti-Money Laundering (AML)</li> <li>Know Your Customer (KYC)</li> <li>Account-network traversal</li> <li>Provider/patient graphs</li> <li>Electronic health record modeling</li> <li>IT asset and dependency graphs</li> <li>Graph analytics vs. transactional graph queries</li> <li>Graph embeddings (introduction)</li> </ul>"},{"location":"course-description/#weeks-12-13-and-14-capstone-projects-and-presentations","title":"Weeks 12, 13 and 14 \u2013 Capstone Projects and Presentations","text":"<ul> <li>Students present a full graph application</li> <li>Modeling choices, data loading, queries, and performance measurements</li> </ul>"},{"location":"course-description/#sample-of-concepts-covered","title":"Sample of Concepts Covered**","text":"<ul> <li>NoSQL Databases</li> <li>Six Representations of Data</li> <li>RDBMS vs. Graph Databases</li> <li>OLAP vs. OLTP Workloads</li> <li>Key-Value Stores</li> <li>Document Databases</li> <li>Graph Stores</li> <li>Tradeoff Analysis / CAP</li> <li>Representations of Knowledge</li> <li>Concept Graphs</li> <li>Index-Free Adjacency</li> <li>Performance &amp; Benchmarking</li> <li>Web Storefront Modeling</li> <li>Learning Management System Modeling</li> <li>Curriculum &amp; Course Dependency Graphs</li> <li>Healthcare Data Graphs</li> <li>IT Asset &amp; Dependency Graphs</li> <li>Financial Transaction Graphs</li> <li>Fraud Detection Graphs</li> <li>Complex Parts &amp; BOM Graphs</li> <li>Supply Chain Models</li> <li>Graph Modeling Anti-Patterns</li> <li>Graph Algorithms</li> <li>openCypher / GSQL querying</li> <li>Data loading pipelines</li> <li>Best practices for graph schema design</li> </ul>"},{"location":"course-description/#topics-not-covered","title":"Topics Not Covered","text":"<ul> <li>How neural networks work</li> <li>Deep learning</li> <li>Complex statistics</li> <li>Details of how other databases work</li> </ul>"},{"location":"course-description/#learning-objectives","title":"Learning Objectives","text":"<p>Organized by Bloom\u2019s Taxonomy \u2013 2001 Revision</p> <p>Below are the learning objectives grouped by Remember \u2192 Understand \u2192 Apply \u2192 Analyze \u2192 Evaluate \u2192 Create.</p>"},{"location":"course-description/#1-remember-factual-knowledge","title":"1. Remember (Factual Knowledge)","text":"<p>Students will be able to:</p> <ul> <li>Define key terms such as node, edge, property, label, schema-optional, and index-free adjacency.</li> <li>List the major categories of NoSQL systems.</li> <li>Identify the components of an LPG information model.</li> <li>Recall common graph query languages (openCypher, GSQL, Gremlin).</li> </ul>"},{"location":"course-description/#2-understand-conceptual-knowledge","title":"2. Understand (Conceptual Knowledge)","text":"<p>Students will be able to:</p> <ul> <li>Explain why traditional RDBMS systems struggle with highly connected data.</li> <li>Describe the tradeoffs among key-value, document, and graph stores.</li> <li>Summarize how graph queries locate patterns more naturally than SQL joins.</li> <li>Explain how concept dependency graphs represent knowledge structures.</li> <li>Compare various real-world graph models (social, supply chain, healthcare, etc.).</li> </ul>"},{"location":"course-description/#3-apply-procedural-knowledge","title":"3. Apply (Procedural Knowledge)","text":"<p>Students will be able to:</p> <ul> <li>Construct simple LPG models using nodes, edges, and properties.</li> <li>Write openCypher or GSQL queries to retrieve and aggregate graph data.</li> <li>Load data sets into a graph database using CSV or ETL pipelines.</li> <li>Implement graph traversal queries that compute multi-hop patterns.</li> <li>Use performance measurement tools to benchmark graph workloads.</li> </ul>"},{"location":"course-description/#4-analyze-breakdown-structure","title":"4. Analyze (Breakdown &amp; Structure)","text":"<p>Students will be able to:</p> <ul> <li>Differentiate between good and bad graph modeling choices.</li> <li>Decompose a domain into entities, relationships, and multi-edge structures.</li> <li>Examine performance logs to identify bottlenecks in graph queries.</li> <li>Analyze alternative graph schema representations for a given domain.</li> <li>Map complex business processes into multi-layered graph models (e.g., supply chain, IT dependency graph).</li> </ul>"},{"location":"course-description/#5-evaluate-judgment-critique","title":"5. Evaluate (Judgment &amp; Critique)","text":"<p>Students will be able to:</p> <ul> <li>Justify when a graph database is more appropriate than an RDBMS or document store.</li> <li>Evaluate competing graph schema designs for clarity, scalability, and performance.</li> <li>Critique query patterns for correctness, efficiency, and maintainability.</li> <li>Assess the appropriateness of chosen benchmarks and workload profiles.</li> <li>Defend the modeling decisions used in their capstone project.</li> </ul>"},{"location":"course-description/#6-create-synthesis-design","title":"6. Create (Synthesis &amp; Design)","text":"<p>Students will be able to:</p> <ul> <li>Design a complete LPG schema for a complex domain (healthcare, finance, supply chain, etc.).</li> <li>Develop multi-step graph queries supporting application requirements.</li> <li>Create an end-to-end graph system including ETL, schema, queries, and visualizations.</li> <li>Build and present a capstone graph application grounded in real-world data.</li> <li>Propose design improvements using graph algorithms or structural pattern refinements.</li> </ul>"},{"location":"feedback/","title":"Feedback on Graph Data Modeling","text":"<p>You are welcome to connect with me on anytime on LinkedIn or submit any issues to GitHub Issue Log.  All pull-requests with fixes to errors or additions are always welcome.</p> <p>If you would like to fill out a short survey and give us ideas on how we can create better tools for intelligent textbooks in the future.</p>"},{"location":"glossary/","title":"Glossary of Terms","text":""},{"location":"glossary/#iso-definition","title":"ISO Definition","text":"<p>A term definition is considered to be consistent with ISO metadata registry guideline 11179 if it meets the following criteria:</p> <ol> <li>Precise</li> <li>Concise</li> <li>Distinct</li> <li>Non-circular</li> <li>Unencumbered with business rules</li> </ol>"},{"location":"glossary/#term","title":"Term","text":"<p>This is the definition of the term.</p>"},{"location":"how-we-built-this-site/","title":"How We Built This Site","text":"<p>This page describes how we built this website and some of  the rationale behind why we made various design choices.</p>"},{"location":"how-we-built-this-site/#python","title":"Python","text":"<p>MicroSims are about how we use generative AI to create animations and simulations.  The language of AI is Python.  So we wanted to create a site that could be easily understood by Python developers.</p>"},{"location":"how-we-built-this-site/#mkdocs-vs-docusaurus","title":"Mkdocs vs. Docusaurus","text":"<p>There are two main tools used by Python developers to write documentation: Mkdocs and Docusaurus.  Mkdocs is easier to use and more popular than Docusaurus. Docusaurus is also optimized for single-page applications. Mkdocs also has an extensive library of themes and plugins. None of us are experts in JavaScript or React. Based on our ChatGPT Analysis of the Tradeoffs we chose mkdocs for this site management.</p>"},{"location":"how-we-built-this-site/#github-and-github-pages","title":"GitHub and GitHub Pages","text":"<p>GitHub is a logical choice to store our  site source code and documentation.  GitHub also has a Custom GitHub Action that does auto-deployment if any files on the site change. We don't currently have this action enabled, but other teams can use this feature if they don't have the ability to do a local build with mkdocs.</p> <p>GitHub also has Issues,  Projects and releases that we can use to manage our bugs and tasks.</p> <p>The best practice for low-cost websites that have public-only content is GitHub Pages. Mkdocs has a command (<code>mkdocs gh-deploy</code>) that does deployment directly to GitHub Pages.  This was an easy choice to make.</p>"},{"location":"how-we-built-this-site/#github-clone","title":"GitHub Clone","text":"<p>If you would like to clone this repository, here are the commands:</p> <pre><code>mkdir projects\ncd projects\ngit clone https://github.com/dmccreary/microsims\n</code></pre>"},{"location":"how-we-built-this-site/#after-changes","title":"After Changes","text":"<p>After you make local changes you must do the following:</p> <pre><code># add the new files to a a local commit transaction\ngit add FILES\n# Execute the a local commit with a message about what and why you are doing the commit\ngit commit -m \"comment\"\n# Update the central GitHub repository\ngit push\n</code></pre>"},{"location":"how-we-built-this-site/#material-theme","title":"Material Theme","text":"<p>We had several options when picking a mkdocs theme:</p> <ol> <li>Mkdocs default</li> <li>Readthedocs</li> <li>Third-Party Themes See Ranking</li> </ol> <p>The Material Theme had 16K stars.  No other theme had over a few hundred. This was also an easy design decision.</p> <p>One key criterial was the social Open Graph tags so that when our users post a link to a simulation, the image of the simulation is included in the link.  Since Material supported this, we used the Material theme. You can see our ChatGPT Design Decision Analysis if you want to check our decision process.</p>"},{"location":"how-we-built-this-site/#enable-edit-icon","title":"Enable Edit Icon","text":"<p>To enable the Edit icon on all pages, you must add the edit_uri and the content.action.edit under the theme features area.</p> <pre><code>edit_uri: edit/master/docs/\n</code></pre> <pre><code>    theme:\n        features:\n            - content.action.edit\n</code></pre>"},{"location":"how-we-built-this-site/#conda-vs-venv","title":"Conda vs VENV","text":"<p>There are two choices for virtual environments.  We can use the native Python venv or use Conda.  venv is simle but is only designed for pure Python projects.  We imagine that this site could use JavaScript and other langauges in the future, so we picked Conda. There is nothing on this microsite that prevents you from using one or the other.  See the ChatGPT Analysis Here.</p> <p>Here is the conda script that we ran to create a new mkdocs environment that also supports the material social imaging libraries.</p> <pre><code>conda deactivate\nconda create -n mkdocs python=3\nconda activate mkdocs\npip install mkdocs \"mkdocs-material[imaging]\"\n</code></pre>"},{"location":"how-we-built-this-site/#mkdocs-commands","title":"Mkdocs Commands","text":"<p>There are three simple mkdoc commands we use.</p>"},{"location":"how-we-built-this-site/#local-build","title":"Local Build","text":"<pre><code>mkdocs build\n</code></pre> <p>This builds your website in a folder called <code>site</code>.  Use this to test that the mkdocs.yml site is working and does not have any errors.</p>"},{"location":"how-we-built-this-site/#run-a-local-server","title":"Run a Local Server","text":"<pre><code>mkdocs serve\n</code></pre> <p>This runs a server on <code>http://localhost:8000</code>. Use this to test the display formatting locally before you push your code up to the GitHub repo.</p> <pre><code>mkdoc gh-deploy\n</code></pre> <p>This pushes everything up to the GitHub Pages site. Note that it does not commit your code to GitHub.</p>"},{"location":"how-we-built-this-site/#mkdocs-material-social-tags","title":"Mkdocs Material Social Tags","text":"<p>We are using the Material Social tags.  This is a work in progress!</p> <p>Here is what we have learned.</p> <ol> <li>There are extensive image processing libraries that can't be installed with just pip.  You will need to run a tool like brew on the Mac to get the libraries installed.</li> <li>Even after <code>brew</code> installs the libraries, you have to get your environment to find the libraries.  The only way I could get that to work was to set up a local UNIX environment variable.</li> </ol> <p>Here is the brew command that I ran:</p> <pre><code>brew install cairo freetype libffi libjpeg libpng zlib\n</code></pre> <p>I then had to add the following to my ~/.zshrc file:</p> <pre><code>export DYLD_FALLBACK_LIBRARY_PATH=/opt/homebrew/lib\n</code></pre> <p>Note that I am running on a Mac with Apple silicon.  This means that the image libraries that brew downloads must be specific to the Mac Arm instruction set.</p>"},{"location":"how-we-built-this-site/#image-generation-and-compression","title":"Image Generation and Compression","text":"<p>I have used ChatGPT to create most of my images.  However, they are too large for most websites.  To compress them down I used  https://tinypng.com/ which is a free tool  for compressing png images without significant loss of quality.  The files created with ChatGPT are typically around 1-2 MB.  After  using the TinyPNG site the size is typically around 200-300KB.</p> <ul> <li>Cover images for blog post #4364</li> <li>Discussion on overriding the Social Card Image</li> </ul>"},{"location":"license/","title":"Creative Commons License","text":"<p>All content in this repository is governed by the following license agreement:</p>"},{"location":"license/#license-type","title":"License Type","text":"<p>Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0 DEED)</p>"},{"location":"license/#link-to-license-agreement","title":"Link to License Agreement","text":"<p>https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en</p>"},{"location":"license/#your-rights","title":"Your Rights","text":"<p>You are free to:</p> <ul> <li>Share \u2014 copy and redistribute the material in any medium or format</li> <li>Adapt \u2014 remix, transform, and build upon the material</li> </ul> <p>The licensor cannot revoke these freedoms as long as you follow the license terms.</p>"},{"location":"license/#restrictions","title":"Restrictions","text":"<ul> <li>Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.</li> <li>NonCommercial \u2014 You may not use the material for commercial purposes.</li> <li>ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.</li> <li>No additional restrictions \u2014 You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.</li> </ul> <p>Notices</p> <p>You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation.</p> <p>No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material.</p> <p>This deed highlights only some of the key features and terms of the actual license. It is not a license and has no legal value. You should carefully review all of the terms and conditions of the actual license before using the licensed material.</p>"},{"location":"references/","title":"Site References","text":"<ol> <li>mkdocs - https://www.mkdocs.org/ - this is our tool for building the website.  It converts Markdown into HTML in the <code>site</code> directory.</li> <li>mkdocs material theme - https://squidfunk.github.io/mkdocs-material/ - this is the theme for our site.  The theme adds the user interface elements that give our site the look and feel.  It also has the features such as social cards.</li> <li>GitHub Pages - https://pages.github.com/ - this is the free tool for hosting public websites created by mkdocs</li> <li>Markdown - https://www.mkdocs.org/user-guide/writing-your-docs/#writing-with-markdown - this is the format we use for text.  It allows us to have headers, lists, tables, links and images without learning HTML.</li> <li>Deploy Mkdocs GitHub Action - https://github.com/marketplace/actions/deploy-mkdocs - this is the tool we use to automatically build our site after edits are checked in with Git.</li> <li>Git Book - https://git-scm.com/book/en/v2 - a useful book on Git.  Just read the first two chapters to learn how to check in new code.</li> <li>Conda - https://conda.io/ - this is a command line tool that keeps our Python libraries organized for each project.</li> <li>VS Code - https://code.visualstudio.com/ - this is the integrated development environment we use to mange the files on our website.</li> <li>Markdown Paste - https://marketplace.visualstudio.com/items?itemName=telesoho.vscode-markdown-paste-image - this is the VS code extension we use to make sure we keep the markdown format generated by ChatGPT.</li> </ol>"},{"location":"chapters/","title":"Chapters","text":"<p>This textbook is organized into 12 chapters covering 200 concepts in graph databases.</p>"},{"location":"chapters/#chapter-overview","title":"Chapter Overview","text":"<ol> <li> <p>Introduction to Graph Thinking and Data Modeling - Establishes foundational concepts including data modeling principles, world models, knowledge representation, and core data structures.</p> </li> <li> <p>Database Systems and NoSQL - Compares RDBMS, OLAP, OLTP, and NoSQL databases to establish why graph databases excel at connected data.</p> </li> <li> <p>Labeled Property Graph Information Model - Introduces the core LPG model covering nodes, edges, properties, labels, and fundamental graph operations.</p> </li> <li> <p>Query Languages for Graph Databases - Covers OpenCypher, GSQL, and GQL query languages with comprehensive syntax and optimization techniques.</p> </li> <li> <p>Performance, Metrics, and Benchmarking - Explores performance fundamentals, indexing strategies, and benchmarking methodologies for graph databases.</p> </li> <li> <p>Graph Algorithms - Covers essential graph algorithms including search, pathfinding, centrality measures, and graph neural networks.</p> </li> <li> <p>Social Network Modeling - Applies graph databases to social networks, organizational structures, and human resources applications.</p> </li> <li> <p>Knowledge Representation and Management - Explores knowledge graphs, ontologies, taxonomies, and enterprise knowledge management systems.</p> </li> <li> <p>Graph Modeling Patterns and Data Loading - Covers design patterns, anti-patterns, and data loading strategies for graph databases.</p> </li> <li> <p>Commerce, Supply Chain, and IT Infrastructure - Demonstrates graph applications in e-commerce, supply chain optimization, and IT asset management.</p> </li> <li> <p>Financial, Healthcare, and Regulatory Applications - Explores domain-specific applications in finance, healthcare, and regulatory compliance.</p> </li> <li> <p>Advanced Topics and Distributed Systems - Covers distributed graph databases, real-time analytics, and capstone project design.</p> </li> </ol>"},{"location":"chapters/#how-to-use-this-textbook","title":"How to Use This Textbook","text":"<p>Progress through the chapters sequentially, as each chapter builds upon concepts introduced in previous chapters. The textbook follows a carefully designed learning path that respects concept dependencies, ensuring you have the necessary foundation before tackling advanced topics. Early chapters establish core principles, middle chapters explore algorithms and applications, and later chapters cover industry-specific use cases and distributed systems.</p> <p>Note: Each chapter includes a list of concepts covered. Make sure to complete prerequisites before moving to advanced chapters.</p>"},{"location":"chapters/01-intro-graph-thinking-data-modeling/","title":"Introduction to Graph Thinking and Data Modeling","text":""},{"location":"chapters/01-intro-graph-thinking-data-modeling/#summary","title":"Summary","text":"<p>This foundational chapter introduces the core principles of data modeling and knowledge representation that underpin graph database thinking. You'll learn how world models shape our understanding of connected information and explore essential data structures that form the building blocks of graph systems. The chapter establishes the conceptual framework needed to understand why graphs are powerful tools for representing complex, interconnected data in modern AI-driven applications.</p>"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 15 concepts from the learning graph:</p> <ol> <li>Data Modeling</li> <li>World Models</li> <li>Knowledge Representation</li> <li>Schema Design</li> <li>Hash Maps</li> <li>Trees</li> <li>Arrays</li> <li>Data Structures</li> <li>Relational Model</li> <li>Normalization</li> <li>Open World Model</li> <li>Closed World Model</li> <li>Minimum Spanning Tree</li> <li>Time Trees</li> <li>Decision Trees</li> </ol>"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#prerequisites","title":"Prerequisites","text":"<p>This chapter assumes only the prerequisites listed in the course description:</p> <ul> <li>Prior coursework in databases or data modeling (recommended)</li> <li>Basic programming knowledge (Python, JavaScript, or similar)</li> <li>Familiarity with data structures (arrays, hash maps, trees)</li> </ul>"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#why-graph-thinking-matters-now","title":"Why Graph Thinking Matters Now","text":"<p>In today's business world, there's a technology sitting right under your nose that could give you a massive competitive edge\u2014yet most companies completely ignore it. Graph databases represent one of the most powerful, underutilized tools in modern data management. While your competitors struggle with slow, clunky traditional databases, you could be making decisions in real-time, discovering hidden patterns, and building intelligent systems that actually understand how things connect.</p> <p>The reason is simple: the world isn't organized in tables and rows. Your customers, products, employees, supply chains, and knowledge all exist in a web of relationships. Traditional relational databases were designed in the 1970s for a different world\u2014one where data sat neatly in spreadsheets. Graph databases, by contrast, treat relationships as first-class citizens, making them exponentially faster and more intuitive for the connected data that drives modern business.</p> <p>This chapter introduces you to a fundamentally different way of thinking about data\u2014one that mirrors how the real world actually works. By the end, you'll understand why some of the world's most innovative companies have quietly adopted graph databases as their secret weapon, and why you should too.</p>"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#the-foundation-data-structures","title":"The Foundation: Data Structures","text":"<p>Before we dive into graphs, let's build from what you already know. In programming, we organize information using data structures\u2014specialized formats for storing and accessing data efficiently. Think of data structures as different types of containers, each optimized for specific tasks.</p> <p>The three most common data structures form the building blocks of nearly every software system:</p> <ul> <li>Arrays - Sequential lists where items are stored in order</li> <li>Hash maps - Key-value pairs that enable instant lookups</li> <li>Trees - Hierarchical structures with parent-child relationships</li> </ul> <p>Understanding these structures is critical because graph databases evolved from recognizing their limitations when dealing with highly connected information.</p>"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#arrays-the-sequential-container","title":"Arrays: The Sequential Container","text":"<p>Arrays store elements in a continuous sequence, like books on a shelf. You access elements by their position (index), which makes arrays incredibly fast when you know exactly where to look.</p> <pre><code>customers = [\"Alice\", \"Bob\", \"Charlie\", \"Diana\"]\nprint(customers[0])  # Output: \"Alice\"\n</code></pre> <p>Arrays excel at ordered data and sequential access. However, they struggle when relationships matter more than order. If you want to know which customers purchased from which vendors, arrays force you to search through every element\u2014a slow process that gets worse as your data grows.</p> Visual Comparison: Array Performance     Type: diagram      Purpose: Illustrate how array search performance degrades with size      Components:     - Three arrays of different sizes (10 elements, 100 elements, 1000 elements)     - Visual representation showing linear search path through array     - Clock icons showing increasing search time     - Search pattern arrows moving left-to-right through elements      Layout:     - Three horizontal rows, one for each array size     - Arrays shown as connected boxes     - Red highlighted box at end showing target element     - Search path shown with curved arrow moving through each box      Labels:     - \"10 elements: ~5 comparisons average\"     - \"100 elements: ~50 comparisons average\"     - \"1000 elements: ~500 comparisons average\"     - \"O(n) linear time complexity\"      Style: Clean line drawing with color-coded elements     Color scheme: Blue boxes for array elements, red for target, yellow for search path      Implementation: SVG diagram with annotations"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#hash-maps-instant-lookups","title":"Hash Maps: Instant Lookups","text":"<p>Hash maps (also called dictionaries or associative arrays) solve the lookup problem brilliantly. Instead of searching through every item, hash maps use a mathematical trick called hashing to instantly find the exact location of any value based on its key.</p> <pre><code>customer_orders = {\n    \"Alice\": 42,\n    \"Bob\": 17,\n    \"Charlie\": 33,\n    \"Diana\": 8\n}\nprint(customer_orders[\"Bob\"])  # Output: 17 (instant lookup!)\n</code></pre> <p>Hash maps are extraordinarily efficient for direct lookups\u2014they find values in constant time regardless of how much data you have. This makes them perfect for simple key-value relationships.</p> <p>But here's the catch: hash maps only work for one-hop relationships. If you need to traverse multiple levels of connections (customers \u2192 orders \u2192 products \u2192 suppliers), you're back to multiple separate lookups, and performance tanks. This limitation becomes critical when modeling real-world business problems.</p> Hash Map Architecture Visualization     Type: diagram      Purpose: Show how hash maps achieve constant-time lookups through hashing      Components:     - Input key (\"Alice\") at top     - Hash function box in middle     - Array of buckets at bottom     - Arrows showing key transformation to index     - Retrieved value highlighted      Process flow:     1. Key \"Alice\" enters hash function     2. Hash function converts to number: hash(\"Alice\") = 7     3. Arrow points to bucket 7 in array     4. Value 42 retrieved from bucket 7      Additional elements:     - Side panel showing other key-value pairs     - \"O(1) constant time\" label     - Collision handling notation (chaining shown with linked nodes)      Visual style: Flowchart-style with clear directional arrows     Color scheme: Green for successful path, orange for hash function, blue for storage array      Implementation: SVG/HTML diagram"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#trees-hierarchical-organization","title":"Trees: Hierarchical Organization","text":"<p>Trees represent hierarchical relationships with a root node at the top and branches extending downward. Each node has exactly one parent (except the root) and can have multiple children. Trees naturally model organizational charts, file systems, and decision-making processes.</p> <pre><code>        CEO\n       /   \\\n      CTO   CFO\n     /  \\     \\\n   Dev  QA   Accounting\n</code></pre> <p>Trees are excellent for hierarchical data and enable efficient searching when organized properly (like binary search trees). However, trees enforce a strict limitation: no node can have multiple parents, and there can be no cycles. Real-world relationships don't follow these rules. An employee might report to multiple managers (matrix organization), customers might influence each other (social networks), and products might depend on each other in circular ways.</p> <p>This is where traditional data structures hit their wall, and where graphs become game-changing.</p>"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#data-modeling-representing-reality","title":"Data Modeling: Representing Reality","text":"<p>Data modeling is the art and science of representing real-world information in a format that computers can process efficiently. Every software system, from Netflix recommendations to banking transactions, relies on data models to organize information.</p> <p>The choice of data model isn't just a technical decision\u2014it's a strategic one that impacts:</p> <ul> <li>How fast your system responds to queries</li> <li>How easily you can add new features</li> <li>How much your infrastructure costs</li> <li>Whether you can discover hidden insights in your data</li> </ul> <p>Most businesses default to what they know: relational databases. But that choice, made without considering alternatives, can put you years behind competitors who've discovered better approaches for connected data.</p>"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#knowledge-representation-capturing-what-you-know","title":"Knowledge Representation: Capturing What You Know","text":"<p>Knowledge representation asks a fundamental question: How do we encode human understanding into computer systems? It's not enough to store data\u2014we need to capture meaning, relationships, and context.</p> <p>Consider a simple business scenario:</p> <ul> <li>\"Alice purchased Product X\"</li> <li>\"Product X was manufactured by Vendor Y\"</li> <li>\"Vendor Y is located in Country Z\"</li> </ul> <p>Traditional databases store these as separate facts in different tables. But the knowledge isn't in the individual facts\u2014it's in how they connect. Graph databases represent knowledge by making those connections explicit and queryable, enabling questions like \"Which countries do my customers ultimately depend on?\" to be answered in milliseconds rather than minutes.</p> Knowledge Representation Comparison     Type: diagram      Purpose: Compare how traditional tables vs. graphs represent the same knowledge      Layout: Two-panel comparison (left: RDBMS, right: Graph)      Left panel - RDBMS representation:     - Three separate tables:       1. Purchases table: (customer_id, product_id, date)       2. Products table: (product_id, vendor_id, name)       3. Vendors table: (vendor_id, country, name)     - Red dotted lines showing foreign key relationships     - Label: \"Knowledge is implicit in foreign keys\"      Right panel - Graph representation:     - Same information shown as connected nodes:       * Alice (Customer node) --PURCHASED--&gt; Product X (Product node)       * Product X --MANUFACTURED_BY--&gt; Vendor Y (Vendor node)       * Vendor Y --LOCATED_IN--&gt; Country Z (Location node)     - Green solid lines showing direct relationships     - Label: \"Knowledge is explicit in relationships\"      Visual styling:     - Tables shown as traditional database tables with rows/columns     - Graph nodes shown as labeled circles     - Relationship arrows with type labels     - Highlighting showing easier traversal path in graph      Color scheme: Orange for RDBMS elements, gold for graph elements      Implementation: Side-by-side SVG comparison diagram"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#world-models-how-systems-understand-reality","title":"World Models: How Systems Understand Reality","text":"<p>A world model is a system's internal representation of how things work. Just as you have a mental model of your workplace (who does what, who reports to whom, where resources are located), software systems need world models to make intelligent decisions.</p> <p>There are two fundamentally different approaches to world models, each with profound implications:</p>"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#closed-world-model","title":"Closed World Model","text":"<p>The closed world model assumes that if something isn't explicitly stated in the database, it's false. Traditional relational databases operate under this assumption. If there's no row saying \"Alice knows Bob,\" then Alice doesn't know Bob\u2014end of story.</p> <p>This works well for controlled environments where you have complete information:</p> <ul> <li>Accounting systems (you know all transactions)</li> <li>Inventory systems (you know all products in stock)</li> <li>Employee databases (you know all employees)</li> </ul> <p>Advantages of closed world:</p> <ul> <li>Simpler queries and logic</li> <li>Guaranteed consistency</li> <li>Predictable behavior</li> </ul> <p>Disadvantages of closed world:</p> <ul> <li>Cannot handle incomplete information</li> <li>Struggles with evolving knowledge</li> <li>Forces premature commitments about what you know</li> </ul>"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#open-world-model","title":"Open World Model","text":"<p>The open world model recognizes that absence of information doesn't mean something is false\u2014it means you don't know yet. This mirrors reality much better. If your database doesn't say \"Alice knows Bob,\" it simply means that relationship hasn't been confirmed, not that it's impossible.</p> <p>Graph databases can operate under either model, but they excel at open world scenarios:</p> <ul> <li>Social networks (you don't know all friendships)</li> <li>Supply chains (new vendors emerge constantly)</li> <li>Knowledge graphs (information is continuously discovered)</li> </ul> <p>Advantages of open world:</p> <ul> <li>Handles incomplete information gracefully</li> <li>Supports incremental knowledge building</li> <li>Adapts to changing reality</li> </ul> <p>This flexibility gives graph-based systems a huge advantage when dealing with real-world complexity. While competitors using rigid closed-world systems struggle to adapt to new information, graph databases seamlessly incorporate new discoveries and evolving relationships.</p> Closed World vs. Open World Model Comparison Table     Type: markdown-table      A comparison table would be embedded here directly in markdown:  <p>Here's how the two models differ in practice:</p> Aspect Closed World Model Open World Model Unknown information Assumed false Assumed unknown Best for Complete, controlled data Evolving, incomplete data Typical use RDBMS, traditional systems Knowledge graphs, AI systems Query behavior Returns definitive yes/no Returns yes/no/unknown Adding new facts Requires schema changes often Seamlessly integrated Example domains Banking, inventory, payroll Social networks, research, recommendations"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#the-relational-model-and-its-limitations","title":"The Relational Model and Its Limitations","text":"<p>The relational model, introduced by Edgar Codd in 1970, revolutionized data management. It organizes data into tables (relations) with rows (records) and columns (attributes), connected through foreign keys. For decades, this model dominated because it solved the critical problems of its era: reducing data redundancy and ensuring consistency.</p>"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#normalization-the-relational-strength","title":"Normalization: The Relational Strength","text":"<p>Normalization is the process of organizing data to minimize redundancy. Instead of repeating customer information in every order record, you store customers once and reference them through IDs.</p> <p>Example of normalization:</p> <p>Unnormalized (redundant): <pre><code>Orders table:\n| order_id | customer_name | customer_email     | product   |\n|----------|---------------|-------------------|-----------|\n| 1        | Alice         | alice@email.com   | Widget    |\n| 2        | Alice         | alice@email.com   | Gadget    |\n| 3        | Bob           | bob@email.com     | Widget    |\n</code></pre></p> <p>Normalized (efficient): <pre><code>Customers table:\n| customer_id | name  | email           |\n|-------------|-------|-----------------|\n| 101         | Alice | alice@email.com |\n| 102         | Bob   | bob@email.com   |\n\nOrders table:\n| order_id | customer_id | product |\n|----------|-------------|---------|\n| 1        | 101         | Widget  |\n| 2        | 101         | Gadget  |\n| 3        | 102         | Widget  |\n</code></pre></p> <p>Normalization brilliantly solves data consistency: update Alice's email once, and all her orders automatically reflect the change. This was perfect for 1970s business applications like inventory and payroll.</p>"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#the-performance-cliff-when-relationships-explode","title":"The Performance Cliff: When Relationships Explode","text":"<p>Here's where relational databases hit their fundamental limit: JOINs. Every relationship traversal requires a JOIN operation\u2014a expensive process where the database matches rows from different tables.</p> <p>One JOIN? Fast enough. Two JOINs? Still manageable. But real business questions require many levels of traversal:</p> <ul> <li>\"Which products do friends of my friends recommend?\" (3 hops)</li> <li>\"What's the supply chain impact if this vendor fails?\" (5+ hops)</li> <li>\"Which skills are required for career paths to executive roles?\" (7+ hops)</li> </ul> <p>Each additional JOIN multiplies the computational cost. By the time you're traversing 4-5 levels of relationships, query times explode from milliseconds to minutes. This isn't a minor inconvenience\u2014it's the difference between building real-time recommendation engines and batch reports that run overnight.</p> <p>See the performance cliff: The interactive chart below demonstrates this dramatic difference. Notice how RDBMS performance degrades exponentially (orange line) while graph databases maintain constant-time performance (gold line). Toggle between logarithmic and linear scales to see the difference from different perspectives.</p> <p>View Chart Fullscreen See Detailed Analysis</p> <p>This performance difference isn't theoretical\u2014it's the reason companies like LinkedIn, eBay, NASA, and Walmart have migrated relationship-heavy workloads to graph databases. While competitors wait minutes for insights, graph-powered systems respond instantly.</p>"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#schema-design-planning-your-data-structure","title":"Schema Design: Planning Your Data Structure","text":"<p>Schema design is the architectural blueprint for how you'll organize data. It defines what entities exist, what properties they have, and how they relate. Good schema design makes your system fast, flexible, and maintainable. Poor schema design creates technical debt that haunts you for years.</p> <p>Traditional relational databases require rigid schemas defined upfront. Adding a new property or relationship type means schema migrations, downtime, and developer headaches. This made sense when business requirements changed slowly, but modern businesses need agility.</p> <p>Graph databases offer schema-optional or schema-flexible approaches. You can enforce schemas when consistency matters (like financial data) but also add new node types, properties, and relationships on the fly as business needs evolve. This flexibility is a competitive weapon\u2014you can experiment, iterate, and adapt faster than competitors locked into rigid relational schemas.</p>"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#special-tree-structures-solving-specific-problems","title":"Special Tree Structures: Solving Specific Problems","text":"<p>Trees aren't just academic concepts\u2014they solve real business problems. Three specialized tree structures appear frequently in modern systems:</p>"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#decision-trees-automating-complex-choices","title":"Decision Trees: Automating Complex Choices","text":"<p>Decision trees represent a series of choices leading to outcomes, like a flowchart. They're widely used in machine learning, business rule engines, and troubleshooting systems.</p> <pre><code>Is customer premium?\n\u251c\u2500 Yes \u2192 Offer expedited shipping\n\u2514\u2500 No \u2192 Is order over $50?\n    \u251c\u2500 Yes \u2192 Offer free shipping\n    \u2514\u2500 No \u2192 Standard shipping only\n</code></pre> <p>Graph databases excel at storing and traversing decision trees because they can represent the logic structure naturally, query it efficiently, and modify rules without rebuilding entire systems.</p>"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#time-trees-organizing-temporal-data","title":"Time Trees: Organizing Temporal Data","text":"<p>Time trees organize events hierarchically by time periods: years contain months, months contain days, days contain hours. This structure enables incredibly efficient time-range queries.</p> <p>Instead of scanning millions of timestamp records, you traverse the tree: - \"Show sales in Q3 2024\" \u2192 Navigate to 2024 \u2192 Q3 \u2192 aggregate all descendants - \"Compare Mondays across all weeks\" \u2192 Traverse day-of-week branches</p> <p>Time trees are essential for time-series analysis, scheduling systems, and historical trend queries. In a graph database, time trees combine naturally with other relationship types, enabling questions like \"How did customer behavior on Mondays in Q3 affect supply chain performance?\" that would be nightmarishly complex in relational systems.</p> Time Tree Structure Visualization     Type: diagram      Purpose: Show how time trees organize temporal data hierarchically for efficient querying      Structure:     - Root: \"All Time\"     - Level 1: Years (2022, 2023, 2024)     - Level 2: Quarters (Q1, Q2, Q3, Q4)     - Level 3: Months (Jan, Feb, Mar...)     - Level 4: Weeks (Week 1, Week 2...)     - Level 5: Days (individual dates)      Visual representation:     - Expand one branch fully (e.g., 2024 \u2192 Q3 \u2192 July \u2192 Week 2 \u2192 July 10)     - Other branches collapsed or partially shown     - Highlight a query path: \"All events in Q3 2024\"     - Show aggregation happening at quarter level      Layout: Top-down tree with root at top      Annotations:     - \"O(log n) time to reach any date\"     - \"Aggregate by traversing subtree\"     - \"Add new events by inserting leaves\"      Color scheme:     - Blue for year nodes     - Green for quarter nodes     - Yellow for month nodes     - Orange for week/day nodes     - Red highlight for query path      Implementation: Interactive SVG tree diagram     Size: 800x600px"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#minimum-spanning-tree-optimizing-networks","title":"Minimum Spanning Tree: Optimizing Networks","text":"<p>A minimum spanning tree is a subset of edges in a graph that connects all nodes with the minimum total weight, without creating cycles. This sounds abstract, but it solves critical real-world problems:</p> <ul> <li>Network design: Connecting offices with minimum cable length</li> <li>Supply chain optimization: Minimizing total shipping distance</li> <li>Utility routing: Designing water, power, or data networks efficiently</li> </ul> <p>Graph databases can calculate minimum spanning trees using algorithms like Kruskal's or Prim's, then store and update them as networks evolve. This gives operations teams real-time answers to questions like \"What's the cheapest way to connect these locations?\" without running expensive batch calculations.</p> <p>Try it yourself: The interactive simulation below demonstrates both Kruskal's and Prim's algorithms. Use the controls to step through the algorithm or watch it run automatically. Notice how both algorithms find the same optimal total weight, even though they select edges in different orders.</p> <p>View MicroSim Fullscreen See Full Documentation</p>"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#the-graph-advantage-why-this-matters-for-your-career","title":"The Graph Advantage: Why This Matters for Your Career","text":"<p>Understanding these fundamental concepts\u2014data structures, data modeling, world models, and specialized algorithms\u2014prepares you for the most significant shift in data management in 50 years.</p> <p>Companies using graph databases report:</p> <ul> <li>10-100x faster query performance for relationship-heavy workloads</li> <li>50-80% reduction in development time for connected data features</li> <li>Significantly lower infrastructure costs due to efficient traversals</li> <li>Faster time-to-market for new features requiring relationship analysis</li> </ul> <p>More importantly, graphs enable entirely new capabilities that are impractical with relational databases:</p> <ul> <li>Real-time fraud detection through network analysis</li> <li>Instant recommendation engines analyzing millions of connections</li> <li>Supply chain resilience planning considering multi-hop dependencies</li> <li>Knowledge graphs powering intelligent assistants</li> <li>Social network analysis revealing hidden influence patterns</li> </ul> <p>The companies leveraging these capabilities aren't all tech giants. They're nimble competitors who recognized that relationships are the new competitive advantage. In industries from healthcare to finance, retail to logistics, graph-powered insights are creating winners and losers.</p>"},{"location":"chapters/01-intro-graph-thinking-data-modeling/#key-takeaways","title":"Key Takeaways","text":"<p>This chapter established the foundational concepts you'll build on throughout this course:</p> <ol> <li>Data structures (arrays, hash maps, trees) each have strengths and limitations\u2014none handle multi-hop relationships efficiently</li> <li>Data modeling choices have strategic business implications, not just technical ones</li> <li>World models (open vs. closed) determine how systems handle incomplete or evolving information</li> <li>The relational model revolutionized data management but hits fundamental performance limits with connected data</li> <li>Normalization solves redundancy but creates JOIN overhead that cripples relationship queries</li> <li>Schema design requires balancing consistency with flexibility\u2014graph databases offer both</li> <li>Specialized tree structures (decision trees, time trees, minimum spanning trees) solve specific business problems efficiently</li> </ol> <p>Most importantly: Traditional approaches to data management create a performance cliff when relationships matter. Companies that recognize this reality and adopt graph databases gain years of competitive advantage while others struggle with overnight batch processes and can't build the real-time, intelligent features customers now expect.</p> <p>In the next chapter, we'll explore how NoSQL databases emerged to challenge relational dominance, and why graph databases represent the culmination of this evolution for relationship-rich data.</p>"},{"location":"chapters/02-database-systems-nosql/","title":"Database Systems and NoSQL","text":""},{"location":"chapters/02-database-systems-nosql/#summary","title":"Summary","text":"<p>This chapter provides a comprehensive comparison of traditional database systems and modern NoSQL alternatives, establishing the context for understanding graph databases. You'll explore the evolution from RDBMS through OLAP and OLTP systems to the diverse NoSQL landscape including key-value stores, document databases, and wide-column stores. By understanding the CAP theorem and tradeoff analysis, you'll gain insight into why graph databases emerged as the optimal solution for relationship-heavy data.</p>"},{"location":"chapters/02-database-systems-nosql/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 10 concepts from the learning graph:</p> <ol> <li>RDBMS</li> <li>OLAP</li> <li>OLTP</li> <li>NoSQL Databases</li> <li>Key-Value Stores</li> <li>Document Databases</li> <li>Wide-Column Stores</li> <li>Graph Databases</li> <li>CAP Theorem</li> <li>Tradeoff Analysis</li> </ol>"},{"location":"chapters/02-database-systems-nosql/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 1: Introduction to Graph Thinking and Data Modeling</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/03-labeled-property-graph-model/","title":"Labeled Property Graph Information Model","text":""},{"location":"chapters/03-labeled-property-graph-model/#summary","title":"Summary","text":"<p>This chapter introduces the Labeled Property Graph (LPG) information model, the foundation of modern graph databases. You'll learn how nodes, edges, properties, and labels work together to create expressive, flexible data models where relationships are first-class citizens. The chapter covers both schema-optional and schema-enforced approaches, explores index-free adjacency for performance, and introduces fundamental graph operations including traversal, pattern matching, and multi-hop queries.</p>"},{"location":"chapters/03-labeled-property-graph-model/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 23 concepts from the learning graph:</p> <ol> <li>Labeled Property Graph</li> <li>Nodes</li> <li>Edges</li> <li>Properties</li> <li>Labels</li> <li>Schema-Optional Modeling</li> <li>Schema-Enforced Modeling</li> <li>Index-Free Adjacency</li> <li>Traversal</li> <li>Graph Query</li> <li>Pattern Matching</li> <li>Multi-Hop Queries</li> <li>Aggregation</li> <li>Path Patterns</li> <li>Constant-Time Neighbor Access</li> <li>First-Class Relationships</li> <li>Edge Direction</li> <li>Graph Data Model</li> <li>Graph Schema</li> <li>Metadata Representation</li> <li>Graph Validation</li> <li>Document Validation</li> <li>Rule Systems</li> </ol>"},{"location":"chapters/03-labeled-property-graph-model/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 1: Introduction to Graph Thinking and Data Modeling</li> <li>Chapter 2: Database Systems and NoSQL</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/04-query-languages/","title":"Query Languages for Graph Databases","text":""},{"location":"chapters/04-query-languages/#summary","title":"Summary","text":"<p>This chapter provides comprehensive coverage of graph query languages including OpenCypher, GSQL, and the emerging GQL standard. You'll master Cypher syntax for pattern matching, learn how to construct complex graph queries with match, where, and return clauses, and explore GSQL's map-reduce pattern for distributed query processing. The chapter emphasizes both declarative and imperative query approaches, query optimization techniques, and performance considerations for production graph applications.</p>"},{"location":"chapters/04-query-languages/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 26 concepts from the learning graph:</p> <ol> <li>OpenCypher</li> <li>GSQL</li> <li>Statistical Query Tuning</li> <li>GQL</li> <li>Cypher Syntax</li> <li>Match Clause</li> <li>Where Clause</li> <li>Return Clause</li> <li>Create Statement</li> <li>Merge Statement</li> <li>Delete Statement</li> <li>Set Clause</li> <li>Graph Patterns</li> <li>Variable Length Paths</li> <li>Shortest Path</li> <li>All Paths</li> <li>Map-Reduce Pattern</li> <li>Accumulators</li> <li>Query Optimization</li> <li>Query Performance</li> <li>Query Latency</li> <li>Query Throughput</li> <li>Declarative Queries</li> <li>Imperative Queries</li> <li>Query Plans</li> <li>Shortest Path Algorithms</li> </ol>"},{"location":"chapters/04-query-languages/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 3: Labeled Property Graph Information Model</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/05-performance-metrics-benchmarking/","title":"Performance, Metrics, and Benchmarking","text":""},{"location":"chapters/05-performance-metrics-benchmarking/#summary","title":"Summary","text":"<p>This chapter explores the performance characteristics that make graph databases excel at relationship-heavy workloads. You'll learn about index-free adjacency's constant-time neighbor access, understand key performance metrics like hop count and node degree, and master indexing strategies including vector indexes and composite indexes. The chapter covers industry-standard benchmarks like LDBC SNB and Graph 500, teaching you how to measure query latency, throughput, and scalability while comparing traversal costs against traditional join operations.</p>"},{"location":"chapters/05-performance-metrics-benchmarking/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Hop Count</li> <li>Degree of Node</li> <li>Indegree</li> <li>Outdegree</li> <li>Edge-to-Node Ratio</li> <li>Graph Indexes</li> <li>Vector Indexes</li> <li>Full-Text Search</li> <li>Composite Indexes</li> <li>Graph Metrics</li> <li>Performance Benchmarking</li> <li>Synthetic Benchmarks</li> <li>Single-Node Benchmarks</li> <li>Multi-Node Benchmarks</li> <li>LDBC SNB Benchmark</li> <li>Graph 500</li> <li>Query Cost Analysis</li> <li>Join Operations</li> <li>Traversal Cost</li> <li>Scalability</li> </ol>"},{"location":"chapters/05-performance-metrics-benchmarking/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 3: Labeled Property Graph Information Model</li> <li>Chapter 4: Query Languages for Graph Databases</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/06-graph-algorithms/","title":"Graph Algorithms","text":""},{"location":"chapters/06-graph-algorithms/#summary","title":"Summary","text":"<p>This chapter covers essential graph algorithms that power modern graph analytics and machine learning applications. You'll learn classic search algorithms like breadth-first and depth-first search, explore pathfinding techniques including A-star and the traveling salesman problem, and master centrality measures that identify important nodes in networks. The chapter progresses to advanced topics including PageRank, community detection, graph neural networks, and graph embeddings that enable machine learning on graph-structured data.</p>"},{"location":"chapters/06-graph-algorithms/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 18 concepts from the learning graph:</p> <ol> <li>Breadth-First Search</li> <li>Depth-First Search</li> <li>A-Star Algorithm</li> <li>Pathfinding</li> <li>Traveling Salesman Problem</li> <li>PageRank</li> <li>Community Detection</li> <li>Centrality Measures</li> <li>Betweenness Centrality</li> <li>Closeness Centrality</li> <li>Graph Embeddings</li> <li>Graph Neural Networks</li> <li>Link Prediction</li> <li>Graph Clustering</li> <li>Connected Components</li> <li>Strongly Connected Components</li> <li>Weakly Connected Components</li> <li>Node Classification</li> </ol>"},{"location":"chapters/06-graph-algorithms/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 3: Labeled Property Graph Information Model</li> <li>Chapter 4: Query Languages for Graph Databases</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/07-social-network-modeling/","title":"Social Network Modeling","text":""},{"location":"chapters/07-social-network-modeling/#summary","title":"Summary","text":"<p>This chapter applies graph database concepts to social network applications, demonstrating how to model friend graphs, influence networks, and organizational structures. You'll learn to represent complex social relationships including followers, activity streams, and user profiles while exploring advanced applications like sentiment analysis integration and fake account detection. The chapter extends to human resources applications including org chart modeling, skill management systems, and task assignment workflows.</p>"},{"location":"chapters/07-social-network-modeling/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 15 concepts from the learning graph:</p> <ol> <li>Social Networks</li> <li>Friend Graphs</li> <li>Influence Graphs</li> <li>Follower Networks</li> <li>Activity Streams</li> <li>User Profiles</li> <li>Relationship Types</li> <li>Sentiment Analysis</li> <li>Natural Language Processing</li> <li>Fake Account Detection</li> <li>Human Resources Modeling</li> <li>Org Chart Models</li> <li>Skill Management</li> <li>Task Assignment</li> <li>Backlog Management</li> </ol>"},{"location":"chapters/07-social-network-modeling/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 3: Labeled Property Graph Information Model</li> <li>Chapter 4: Query Languages for Graph Databases</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/08-knowledge-representation-management/","title":"Knowledge Representation and Management","text":""},{"location":"chapters/08-knowledge-representation-management/#summary","title":"Summary","text":"<p>This chapter explores how graph databases excel at representing and managing knowledge structures including ontologies, taxonomies, and concept dependency graphs. You'll learn the Simple Knowledge Organization System (SKOS) for managing preferred and alternate labels, create controlled vocabularies and glossaries, and design curriculum graphs that model learning dependencies. The chapter covers knowledge management at multiple scales from personal knowledge graphs and note-taking systems to enterprise-wide knowledge capture and management platforms.</p>"},{"location":"chapters/08-knowledge-representation-management/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Concept Dependency Graphs</li> <li>Curriculum Graphs</li> <li>Ontologies</li> <li>SKOS</li> <li>Preferred Labels</li> <li>Alternate Labels</li> <li>Acronym Lists</li> <li>Glossaries</li> <li>Controlled Vocabularies</li> <li>Taxonomies</li> <li>Enterprise Knowledge</li> <li>Department Knowledge</li> <li>Project Knowledge</li> <li>Personal Knowledge Graphs</li> <li>Note-Taking Systems</li> <li>Knowledge Capture</li> <li>Tacit Knowledge</li> <li>Codifiable Knowledge</li> <li>Knowledge Management</li> <li>Action Item Extraction</li> </ol>"},{"location":"chapters/08-knowledge-representation-management/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 3: Labeled Property Graph Information Model</li> <li>Chapter 4: Query Languages for Graph Databases</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/09-modeling-patterns-data-loading/","title":"Graph Modeling Patterns and Data Loading","text":""},{"location":"chapters/09-modeling-patterns-data-loading/#summary","title":"Summary","text":"<p>This chapter covers essential design patterns and anti-patterns for graph data modeling, helping you create maintainable and performant graph schemas. You'll explore subgraphs, supernodes, hyperedges, and multi-edges while learning time-based modeling patterns for temporal data and IoT events. The chapter provides comprehensive coverage of data loading strategies including ETL pipelines, CSV and JSON import techniques, and bulk versus incremental loading approaches, along with schema evolution and migration best practices.</p>"},{"location":"chapters/09-modeling-patterns-data-loading/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 18 concepts from the learning graph:</p> <ol> <li>Subgraphs</li> <li>Supernodes</li> <li>Anti-Patterns</li> <li>Hyperedges</li> <li>Multi-Edges</li> <li>Time-Based Modeling</li> <li>IoT Event Modeling</li> <li>Bitemporal Models</li> <li>Graph Quality Metrics</li> <li>Model Validation</li> <li>Schema Evolution</li> <li>Data Migration</li> <li>ETL Pipelines</li> <li>CSV Import</li> <li>JSON Import</li> <li>Data Loading</li> <li>Bulk Loading</li> <li>Incremental Loading</li> </ol>"},{"location":"chapters/09-modeling-patterns-data-loading/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 3: Labeled Property Graph Information Model</li> <li>Chapter 5: Performance, Metrics, and Benchmarking</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/10-commerce-supply-chain-it/","title":"Commerce, Supply Chain, and IT Infrastructure","text":""},{"location":"chapters/10-commerce-supply-chain-it/#summary","title":"Summary","text":"<p>This chapter demonstrates graph database applications in e-commerce, supply chain management, and IT infrastructure. You'll learn to model web storefronts with product catalogs, design recommendation engines using graph algorithms, and manage complex bill-of-materials structures for manufacturing. The chapter extends to IT asset management, network topology modeling, configuration management, and critical operational applications including impact analysis and root cause analysis for infrastructure troubleshooting.</p>"},{"location":"chapters/10-commerce-supply-chain-it/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 12 concepts from the learning graph:</p> <ol> <li>Web Storefront Models</li> <li>Product Catalogs</li> <li>Recommendation Engines</li> <li>Bill of Materials</li> <li>Complex Parts</li> <li>Supply Chain Modeling</li> <li>IT Asset Management</li> <li>Dependency Graphs</li> <li>Network Topology</li> <li>Configuration Management</li> <li>Impact Analysis</li> <li>Root Cause Analysis</li> </ol>"},{"location":"chapters/10-commerce-supply-chain-it/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 3: Labeled Property Graph Information Model</li> <li>Chapter 6: Graph Algorithms</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/11-financial-healthcare-regulatory/","title":"Financial, Healthcare, and Regulatory Applications","text":""},{"location":"chapters/11-financial-healthcare-regulatory/#summary","title":"Summary","text":"<p>This chapter explores graph database applications in highly regulated industries including finance and healthcare. You'll learn to model financial transaction networks, implement fraud detection systems using community detection algorithms, and build anti-money laundering (AML) and know-your-customer (KYC) compliance systems. The chapter covers healthcare-specific applications including provider-patient graphs, electronic health record modeling, and clinical pathway optimization, while addressing regulatory compliance, data lineage tracking, and master data management requirements common across regulated industries.</p>"},{"location":"chapters/11-financial-healthcare-regulatory/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 13 concepts from the learning graph:</p> <ol> <li>Financial Transactions</li> <li>Fraud Detection</li> <li>Anti-Money Laundering</li> <li>Know Your Customer</li> <li>Account Networks</li> <li>Healthcare Graphs</li> <li>Provider-Patient Graphs</li> <li>Electronic Health Records</li> <li>Clinical Pathways</li> <li>Regulatory Compliance</li> <li>Data Lineage</li> <li>Master Data Management</li> <li>Reference Data Models</li> </ol>"},{"location":"chapters/11-financial-healthcare-regulatory/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 3: Labeled Property Graph Information Model</li> <li>Chapter 6: Graph Algorithms</li> <li>Chapter 7: Social Network Modeling</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/12-advanced-topics-distributed-systems/","title":"Advanced Topics and Distributed Systems","text":""},{"location":"chapters/12-advanced-topics-distributed-systems/#summary","title":"Summary","text":"<p>This capstone chapter covers advanced graph database concepts including distributed architectures, real-time analytics, and visualization techniques. You'll explore graph partitioning and sharding strategies for horizontal scalability, understand replication and consistency models in distributed systems, and learn to design interactive graph visualizations. The chapter culminates with capstone project design guidance, helping you synthesize all course concepts into a complete end-to-end graph application that demonstrates mastery of graph database modeling, querying, performance optimization, and real-world application development.</p>"},{"location":"chapters/12-advanced-topics-distributed-systems/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 10 concepts from the learning graph:</p> <ol> <li>Distributed Graph Databases</li> <li>Graph Partitioning</li> <li>Sharding Strategies</li> <li>Replication</li> <li>Consistency Models</li> <li>Graph Visualization</li> <li>Interactive Queries</li> <li>Real-Time Analytics</li> <li>Batch Processing</li> <li>Capstone Project Design</li> </ol>"},{"location":"chapters/12-advanced-topics-distributed-systems/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Database Systems and NoSQL</li> <li>Chapter 3: Labeled Property Graph Information Model</li> <li>Chapter 4: Query Languages for Graph Databases</li> <li>Chapter 5: Performance, Metrics, and Benchmarking</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"learning-graph/","title":"Learning Graph for Introduction to Graph Databases","text":"<p>This section contains the learning graph for this textbook.  A learning graph is a graph of concepts used in this textbook.  Each concept is represented by a node in a network graph.  Concepts are connected by directed edges that indicate what concepts each node depends on before that concept is understood by the student.</p> <p>A learning graph is the foundational data structure for intelligent textbooks that can recommend learning paths. A learning graph is like a roadmap of concepts to help students arrive at their learning goals.</p> <p>At the left of the learning graph are prerequisite or foundational concepts.  They have no outbound edges.  They only have inbound edges for other concepts that depend on understanding these foundational prerequisite concepts.  At the far right we have the most advanced concepts in the course.  To master these concepts you must understand all the concepts that they point to.</p> <p>Here are other files used by the learning graph.</p>"},{"location":"learning-graph/#course-description","title":"Course Description","text":"<p>We use the Course Description as the source document for the concepts that are included in this course. The course description uses the 2001 Bloom taxonomy to order learning objectives.</p>"},{"location":"learning-graph/#list-of-concepts","title":"List of Concepts","text":"<p>We use generative AI to convert the course description into a Concept List. Each concept is in the form of a short Title Case label with most labels under 32 characters long.</p>"},{"location":"learning-graph/#concept-dependency-list","title":"Concept Dependency List","text":"<p>We next use generative AI to create a Directed Acyclic Graph (DAG).  DAGs do not have cycles where concepts depend on themselves.  We provide the DAG in two formats.  One is a CSV file and the other format is a JSON file that uses the vis-network JavaScript library format.  The vis-network format uses <code>nodes</code>, <code>edges</code> and <code>metadata</code> elements with edges containing <code>from</code> and <code>to</code> properties.  This makes it easy for you to view and edit the learning graph using an editor built with the vis-network tools.</p>"},{"location":"learning-graph/#analysis-documentation","title":"Analysis &amp; Documentation","text":""},{"location":"learning-graph/#course-description-quality-assessment","title":"Course Description Quality Assessment","text":"<p>This report rates the overall quality of the course description for the purpose of generating a learning graph.</p> <ul> <li>Course description fields and content depth analysis</li> <li>Validates course description has sufficient depth for generating 200 concepts</li> <li>Compares course description against similar courses</li> <li>Identifies content gaps and strengths</li> <li>Suggests areas of improvement</li> </ul> <p>View the Course Description Quality Assessment</p>"},{"location":"learning-graph/#learning-graph-quality-validation","title":"Learning Graph Quality Validation","text":"<p>This report gives you an overall assessment of the quality of the learning graph. It uses graph algorithms to look for specific quality patterns in the graph.</p> <ul> <li>Graph structure validation - all concepts are connected</li> <li>DAG validation (no cycles detected)</li> <li>Foundational concepts: 6 entry points</li> <li>Indegree distribution analysis</li> <li>Longest dependency chains (18 levels)</li> <li>Connectivity: 100% of nodes connected to the main cluster</li> </ul> <p>View the Learning Graph Quality Validation</p>"},{"location":"learning-graph/#concept-taxonomy","title":"Concept Taxonomy","text":"<p>In order to see patterns in the learning graph, it is useful to assign colors to each concept based on the concept type.  We use generative AI to create about a dozen categories for our concepts and then place each concept into a single primary classifier.</p> <ul> <li>A concept classifier taxonomy with 12 categories</li> <li>Category organization - foundational elements first, course capstone project ideas last</li> <li>Balanced categories (2.0% - 21.0% each)</li> <li>All categories under 30% threshold</li> <li>Pedagogical flow recommendations</li> <li>Clear 3-5 letter abbreviations for use in CSV file</li> </ul> <p>View the Concept Taxonomy</p>"},{"location":"learning-graph/#taxonomy-distribution","title":"Taxonomy Distribution","text":"<p>This reports shows how many concepts fit into each category of the taxonomy. Our goal is a somewhat balanced taxonomy where each category holds an equal number of concepts.  We also don't want any category to contain over 30% of our concepts.</p> <ul> <li>Statistical breakdown showing 12 taxonomies across 200 concepts</li> <li>Detailed concept listing by category</li> <li>Visual distribution table</li> <li>Balance verification - largest category (GRAPH) at 21%</li> </ul> <p>View the Taxonomy Distribution Report</p>"},{"location":"learning-graph/concept-list/","title":"Concept List for Introduction to Graph Databases","text":"<p>Total Concepts: 200 Generated: 2025-11-18 Skill Version: 0.02</p>"},{"location":"learning-graph/concept-list/#foundational-concepts-1-20","title":"Foundational Concepts (1-20)","text":"<ol> <li>Data Modeling</li> <li>World Models</li> <li>Knowledge Representation</li> <li>RDBMS</li> <li>OLAP</li> <li>OLTP</li> <li>NoSQL Databases</li> <li>Key-Value Stores</li> <li>Document Databases</li> <li>Wide-Column Stores</li> <li>Graph Databases</li> <li>CAP Theorem</li> <li>Tradeoff Analysis</li> <li>Schema Design</li> <li>Data Structures</li> <li>Hash Maps</li> <li>Trees</li> <li>Arrays</li> <li>Relational Model</li> <li>Normalization</li> </ol>"},{"location":"learning-graph/concept-list/#graph-database-fundamentals-21-45","title":"Graph Database Fundamentals (21-45)","text":"<ol> <li>Labeled Property Graph</li> <li>Nodes</li> <li>Edges</li> <li>Properties</li> <li>Labels</li> <li>Schema-Optional Modeling</li> <li>Schema-Enforced Modeling</li> <li>Index-Free Adjacency</li> <li>Traversal</li> <li>Graph Query</li> <li>Pattern Matching</li> <li>Multi-Hop Queries</li> <li>Aggregation</li> <li>Path Patterns</li> <li>Constant-Time Neighbor Access</li> <li>First-Class Relationships</li> <li>Edge Direction</li> <li>Graph Data Model</li> <li>Graph Schema</li> <li>Metadata Representation</li> <li>Open World Model</li> <li>Closed World Model</li> <li>Graph Validation</li> <li>Document Validation</li> <li>Rule Systems</li> </ol>"},{"location":"learning-graph/concept-list/#query-languages-46-70","title":"Query Languages (46-70)","text":"<ol> <li>OpenCypher</li> <li>GSQL</li> <li>Statistical Query Tuning</li> <li>GQL</li> <li>Cypher Syntax</li> <li>Match Clause</li> <li>Where Clause</li> <li>Return Clause</li> <li>Create Statement</li> <li>Merge Statement</li> <li>Delete Statement</li> <li>Set Clause</li> <li>Graph Patterns</li> <li>Variable Length Paths</li> <li>Shortest Path</li> <li>All Paths</li> <li>Map-Reduce Pattern</li> <li>Accumulators</li> <li>Query Optimization</li> <li>Query Performance</li> <li>Query Latency</li> <li>Query Throughput</li> <li>Declarative Queries</li> <li>Imperative Queries</li> <li>Query Plans</li> </ol>"},{"location":"learning-graph/concept-list/#performance-and-indexing-71-90","title":"Performance and Indexing (71-90)","text":"<ol> <li>Hop Count</li> <li>Degree of Node</li> <li>Indegree</li> <li>Outdegree</li> <li>Edge-to-Node Ratio</li> <li>Graph Indexes</li> <li>Vector Indexes</li> <li>Full-Text Search</li> <li>Composite Indexes</li> <li>Graph Metrics</li> <li>Performance Benchmarking</li> <li>Synthetic Benchmarks</li> <li>Single-Node Benchmarks</li> <li>Multi-Node Benchmarks</li> <li>LDBC SNB Benchmark</li> <li>Graph 500</li> <li>Query Cost Analysis</li> <li>Join Operations</li> <li>Traversal Cost</li> <li>Scalability</li> </ol>"},{"location":"learning-graph/concept-list/#graph-algorithms-91-110","title":"Graph Algorithms (91-110)","text":"<ol> <li>Breadth-First Search</li> <li>Depth-First Search</li> <li>A-Star Algorithm</li> <li>Pathfinding</li> <li>Traveling Salesman Problem</li> <li>PageRank</li> <li>Community Detection</li> <li>Centrality Measures</li> <li>Betweenness Centrality</li> <li>Closeness Centrality</li> <li>Graph Embeddings</li> <li>Graph Neural Networks</li> <li>Link Prediction</li> <li>Node Classification</li> <li>Graph Clustering</li> <li>Shortest Path Algorithms</li> <li>Minimum Spanning Tree</li> <li>Connected Components</li> <li>Strongly Connected Components</li> <li>Weakly Connected Components</li> </ol>"},{"location":"learning-graph/concept-list/#social-network-modeling-111-125","title":"Social Network Modeling (111-125)","text":"<ol> <li>Social Networks</li> <li>Friend Graphs</li> <li>Influence Graphs</li> <li>Follower Networks</li> <li>Activity Streams</li> <li>User Profiles</li> <li>Relationship Types</li> <li>Sentiment Analysis</li> <li>Natural Language Processing</li> <li>Fake Account Detection</li> <li>Human Resources Modeling</li> <li>Org Chart Models</li> <li>Skill Management</li> <li>Task Assignment</li> <li>Backlog Management</li> </ol>"},{"location":"learning-graph/concept-list/#knowledge-representation-126-145","title":"Knowledge Representation (126-145)","text":"<ol> <li>Concept Dependency Graphs</li> <li>Curriculum Graphs</li> <li>Ontologies</li> <li>SKOS</li> <li>Preferred Labels</li> <li>Alternate Labels</li> <li>Acronym Lists</li> <li>Glossaries</li> <li>Controlled Vocabularies</li> <li>Taxonomies</li> <li>Enterprise Knowledge</li> <li>Department Knowledge</li> <li>Project Knowledge</li> <li>Personal Knowledge Graphs</li> <li>Note-Taking Systems</li> <li>Knowledge Capture</li> <li>Tacit Knowledge</li> <li>Codifiable Knowledge</li> <li>Knowledge Management</li> <li>Action Item Extraction</li> </ol>"},{"location":"learning-graph/concept-list/#graph-modeling-patterns-146-165","title":"Graph Modeling Patterns (146-165)","text":"<ol> <li>Subgraphs</li> <li>Supernodes</li> <li>Anti-Patterns</li> <li>Hyperedges</li> <li>Multi-Edges</li> <li>Time-Based Modeling</li> <li>Time Trees</li> <li>IoT Event Modeling</li> <li>Decision Trees</li> <li>Bitemporal Models</li> <li>Graph Quality Metrics</li> <li>Model Validation</li> <li>Schema Evolution</li> <li>Data Migration</li> <li>ETL Pipelines</li> <li>CSV Import</li> <li>JSON Import</li> <li>Data Loading</li> <li>Bulk Loading</li> <li>Incremental Loading</li> </ol>"},{"location":"learning-graph/concept-list/#industry-applications-166-190","title":"Industry Applications (166-190)","text":"<ol> <li>Web Storefront Models</li> <li>Product Catalogs</li> <li>Recommendation Engines</li> <li>Bill of Materials</li> <li>Complex Parts</li> <li>Supply Chain Modeling</li> <li>Financial Transactions</li> <li>Fraud Detection</li> <li>Anti-Money Laundering</li> <li>Know Your Customer</li> <li>Account Networks</li> <li>Healthcare Graphs</li> <li>Provider-Patient Graphs</li> <li>Electronic Health Records</li> <li>Clinical Pathways</li> <li>IT Asset Management</li> <li>Dependency Graphs</li> <li>Network Topology</li> <li>Configuration Management</li> <li>Impact Analysis</li> <li>Root Cause Analysis</li> <li>Regulatory Compliance</li> <li>Data Lineage</li> <li>Master Data Management</li> <li>Reference Data Models</li> </ol>"},{"location":"learning-graph/concept-list/#advanced-topics-191-200","title":"Advanced Topics (191-200)","text":"<ol> <li>Distributed Graph Databases</li> <li>Graph Partitioning</li> <li>Sharding Strategies</li> <li>Replication</li> <li>Consistency Models</li> <li>Graph Visualization</li> <li>Interactive Queries</li> <li>Real-Time Analytics</li> <li>Batch Processing</li> <li>Capstone Project Design</li> </ol>"},{"location":"learning-graph/concept-taxonomy/","title":"Concept Taxonomy","text":"<p>Date: 2025-11-18 Total Concepts: 200 Target Categories: 12</p>"},{"location":"learning-graph/concept-taxonomy/#taxonomy-categories","title":"Taxonomy Categories","text":""},{"location":"learning-graph/concept-taxonomy/#1-foundation-concepts-found","title":"1. Foundation Concepts (FOUND)","text":"<p>Description: Core foundational concepts including data structures, data modeling principles, and basic knowledge representation that underpin all graph database learning.</p> <p>Typical Concepts: Data Modeling, World Models, Knowledge Representation, Schema Design, Hash Maps, Trees, Arrays</p>"},{"location":"learning-graph/concept-taxonomy/#2-database-systems-dbsys","title":"2. Database Systems (DBSYS)","text":"<p>Description: Traditional and NoSQL database systems including RDBMS, OLAP, OLTP, key-value stores, document databases, and wide-column stores that provide context for graph databases.</p> <p>Typical Concepts: RDBMS, NoSQL, Key-Value Stores, Document Databases, CAP Theorem, Normalization, Relational Model</p>"},{"location":"learning-graph/concept-taxonomy/#3-graph-data-model-graph","title":"3. Graph Data Model (GRAPH)","text":"<p>Description: Core graph database concepts including the Labeled Property Graph model, nodes, edges, properties, labels, schema approaches, and fundamental graph structures.</p> <p>Typical Concepts: Labeled Property Graph, Nodes, Edges, Properties, Labels, Index-Free Adjacency, Traversal, Schema-Optional Modeling</p>"},{"location":"learning-graph/concept-taxonomy/#4-query-languages-query","title":"4. Query Languages (QUERY)","text":"<p>Description: Graph query languages and syntax including OpenCypher, GSQL, GQL, query patterns, path expressions, and query optimization techniques.</p> <p>Typical Concepts: OpenCypher, GSQL, GQL, Cypher Syntax, Match Clause, Pattern Matching, Variable Length Paths, Query Optimization</p>"},{"location":"learning-graph/concept-taxonomy/#5-performance-perf","title":"5. Performance (PERF)","text":"<p>Description: Performance analysis, benchmarking, indexing strategies, and metrics for evaluating graph database systems.</p> <p>Typical Concepts: Performance Benchmarking, Graph Indexes, Query Latency, LDBC SNB Benchmark, Graph 500, Scalability, Hop Count</p>"},{"location":"learning-graph/concept-taxonomy/#6-graph-algorithms-algo","title":"6. Graph Algorithms (ALGO)","text":"<p>Description: Classic and modern graph algorithms including search, pathfinding, centrality measures, community detection, and graph neural networks.</p> <p>Typical Concepts: Breadth-First Search, Depth-First Search, PageRank, Community Detection, Pathfinding, Graph Neural Networks</p>"},{"location":"learning-graph/concept-taxonomy/#7-social-networks-social","title":"7. Social Networks (SOCIAL)","text":"<p>Description: Social network modeling including friend graphs, influence networks, organizational structures, activity streams, and human resources applications.</p> <p>Typical Concepts: Social Networks, Friend Graphs, Org Chart Models, Skill Management, Follower Networks, Influence Graphs</p>"},{"location":"learning-graph/concept-taxonomy/#8-knowledge-management-know","title":"8. Knowledge Management (KNOW)","text":"<p>Description: Knowledge representation systems including ontologies, SKOS, taxonomies, glossaries, personal knowledge graphs, and enterprise knowledge management.</p> <p>Typical Concepts: Ontologies, SKOS, Concept Dependency Graphs, Personal Knowledge Graphs, Enterprise Knowledge, Taxonomies</p>"},{"location":"learning-graph/concept-taxonomy/#9-modeling-patterns-pattern","title":"9. Modeling Patterns (PATTERN)","text":"<p>Description: Graph modeling patterns, anti-patterns, ETL processes, data loading strategies, and schema evolution approaches.</p> <p>Typical Concepts: Subgraphs, Time-Based Modeling, ETL Pipelines, Data Migration, Hyperedges, Schema Evolution</p>"},{"location":"learning-graph/concept-taxonomy/#10-financial-applications-fin","title":"10. Financial Applications (FIN)","text":"<p>Description: Financial transaction modeling, fraud detection, anti-money laundering, know-your-customer, and account network analysis.</p> <p>Typical Concepts: Financial Transactions, Fraud Detection, Anti-Money Laundering, Know Your Customer, Account Networks</p>"},{"location":"learning-graph/concept-taxonomy/#11-healthcare-applications-health","title":"11. Healthcare Applications (HEALTH)","text":"<p>Description: Healthcare-specific graph applications including provider-patient graphs, electronic health records, and clinical pathways.</p> <p>Typical Concepts: Healthcare Graphs, Provider-Patient Graphs, Electronic Health Records, Clinical Pathways</p>"},{"location":"learning-graph/concept-taxonomy/#12-supply-chain-it-supply","title":"12. Supply Chain &amp; IT (SUPPLY)","text":"<p>Description: Supply chain modeling, bill of materials, IT asset management, dependency graphs, network topology, and infrastructure applications.</p> <p>Typical Concepts: Supply Chain Modeling, Bill of Materials, IT Asset Management, Dependency Graphs, Network Topology</p>"},{"location":"learning-graph/concept-taxonomy/#13-advanced-topics-adv","title":"13. Advanced Topics (ADV)","text":"<p>Description: Advanced concepts including distributed graph databases, graph visualization, real-time analytics, and capstone projects.</p> <p>Typical Concepts: Distributed Graph Databases, Graph Partitioning, Graph Visualization, Real-Time Analytics, Capstone Project Design</p>"},{"location":"learning-graph/concept-taxonomy/#taxonomy-design-principles","title":"Taxonomy Design Principles","text":"<ol> <li>Pedagogical Organization: Categories follow a logical learning progression from foundations to applications</li> <li>Even Distribution: Each category targets 12-20 concepts to avoid over-representation</li> <li>Clear Boundaries: Each concept has a clear primary category</li> <li>Progressive Complexity: Foundation \u2192 Core \u2192 Advanced \u2192 Applications</li> <li>Industry Relevance: Application categories reflect real-world use cases</li> </ol>"},{"location":"learning-graph/course-description-assessment/","title":"Course Description Quality Assessment","text":"<p>Date: 2025-11-18 Skill Version: 0.02</p>"},{"location":"learning-graph/course-description-assessment/#quality-assessment-results","title":"Quality Assessment Results","text":"Element Points Available Points Awarded Assessment Title 5 5 \u2713 Clear, descriptive: \"Introduction to Graph Databases\" Target Audience 5 5 \u2713 Specific: \"Undergraduate (Junior/Senior) or Graduate Introductory Level\" Prerequisites 5 5 \u2713 Well-defined with 3 specific requirements Main Topics Covered 10 10 \u2713 Comprehensive 14-week outline with detailed topics Topics Excluded 5 5 \u2713 Clear \"Topics Not Covered\" section Learning Outcomes Header 5 5 \u2713 Clear \"Learning Objectives\" section with Bloom's Taxonomy organization Remember Level 10 10 \u2713 4 specific, actionable outcomes (define, list, identify, recall) Understand Level 10 10 \u2713 5 specific outcomes (explain, describe, summarize, compare) Apply Level 10 10 \u2713 5 specific outcomes (construct, write, load, implement, use) Analyze Level 10 10 \u2713 5 specific outcomes (differentiate, decompose, examine, analyze, map) Evaluate Level 10 10 \u2713 5 specific outcomes (justify, evaluate, critique, assess, defend) Create Level 10 10 \u2713 5 specific outcomes including capstone project (design, develop, create, build, propose) Descriptive Context 5 5 \u2713 Rich course overview with real-world applications and case studies"},{"location":"learning-graph/course-description-assessment/#overall-quality-score-95100","title":"Overall Quality Score: 95/100","text":""},{"location":"learning-graph/course-description-assessment/#strengths","title":"Strengths","text":"<ol> <li>Exceptional Bloom's Taxonomy coverage: Each cognitive level has multiple, well-articulated outcomes using proper action verbs</li> <li>Comprehensive topic coverage: 14-week outline with depth and breadth covering fundamentals to advanced applications</li> <li>Real-world focus: Multiple case studies and industry-specific models (healthcare, finance, supply chain, fraud detection)</li> <li>Clear scope boundaries: Explicitly states what's not covered</li> <li>Strong capstone component: Multi-week project demonstrating synthesis and application</li> <li>Well-structured prerequisites: Appropriate for the target audience</li> <li>Progressive difficulty: Builds from fundamentals (Week 1-3) through intermediate (Week 4-9) to advanced applications (Week 10-14)</li> </ol>"},{"location":"learning-graph/course-description-assessment/#minor-suggestions-for-improvement","title":"Minor Suggestions for Improvement","text":"<ul> <li>Week 9 appears twice in the outline (Graph Algorithms and Graph Modeling Patterns) - minor numbering issue</li> <li>Could benefit from explicit mention of assessment methods (exams, projects, etc.)</li> </ul>"},{"location":"learning-graph/course-description-assessment/#concept-generation-estimate","title":"Concept Generation Estimate","text":"<p>Based on this course description, I estimate 200+ high-quality concepts can be generated covering:</p> <ul> <li>Foundational concepts (15-20): NoSQL types, graph components, data models, RDBMS vs Graph</li> <li>Query languages and syntax (20-25): openCypher, GSQL, GQL, Gremlin patterns</li> <li>Performance and architecture (20-25): Index-free adjacency, benchmarking, scalability, traversal</li> <li>Modeling patterns (30-35): Social networks, knowledge graphs, time-based patterns, hyperedges</li> <li>Industry applications (40-50): Healthcare, finance, supply chain, fraud detection, BOM, KYC/AML, web storefronts</li> <li>Algorithms (20-25): BFS, DFS, PageRank, community detection, pathfinding, A*</li> <li>Advanced topics (30-40): Graph embeddings, GNNs, distributed systems, validation, rules</li> </ul>"},{"location":"learning-graph/course-description-assessment/#recommendation","title":"Recommendation","text":"<p>\u2705 PROCEED - This course description is excellent and well above the 70-point threshold for generating a high-quality learning graph. The comprehensive topic coverage, clear learning objectives across all Bloom's Taxonomy levels, and real-world applications provide an outstanding foundation for creating 200 meaningful, interconnected concepts.</p>"},{"location":"learning-graph/quality-metrics/","title":"Learning Graph Quality Metrics Report","text":""},{"location":"learning-graph/quality-metrics/#overview","title":"Overview","text":"<ul> <li>Total Concepts: 200</li> <li>Foundational Concepts (no dependencies): 6</li> <li>Concepts with Dependencies: 194</li> <li>Average Dependencies per Concept: 1.65</li> </ul>"},{"location":"learning-graph/quality-metrics/#graph-structure-validation","title":"Graph Structure Validation","text":"<ul> <li>Valid DAG Structure: \u274c No</li> <li>Self-Dependencies: None detected \u2705</li> <li>Cycles Detected: 0</li> </ul>"},{"location":"learning-graph/quality-metrics/#foundational-concepts","title":"Foundational Concepts","text":"<p>These concepts have no prerequisites:</p> <ul> <li>2: World Models</li> <li>3: Knowledge Representation</li> <li>14: Schema Design</li> <li>15: Hash Maps</li> <li>16: Trees</li> <li>17: Arrays</li> </ul>"},{"location":"learning-graph/quality-metrics/#dependency-chain-analysis","title":"Dependency Chain Analysis","text":"<ul> <li>Maximum Dependency Chain Length: 18</li> </ul>"},{"location":"learning-graph/quality-metrics/#longest-learning-path","title":"Longest Learning Path:","text":"<ol> <li>World Models (ID: 2)</li> <li>Data Modeling (ID: 1)</li> <li>RDBMS (ID: 4)</li> <li>NoSQL Databases (ID: 7)</li> <li>Graph Databases (ID: 11)</li> <li>Nodes (ID: 22)</li> <li>Edges (ID: 23)</li> <li>Properties (ID: 24)</li> <li>Labeled Property Graph (ID: 21)</li> <li>Graph Query (ID: 30)</li> <li>OpenCypher (ID: 46)</li> <li>Cypher Syntax (ID: 50)</li> <li>Match Clause (ID: 51)</li> <li>Variable Length Paths (ID: 59)</li> <li>Shortest Path (ID: 60)</li> <li>Pathfinding (ID: 94)</li> <li>Impact Analysis (ID: 185)</li> <li>Root Cause Analysis (ID: 186)</li> </ol>"},{"location":"learning-graph/quality-metrics/#orphaned-nodes-analysis","title":"Orphaned Nodes Analysis","text":"<ul> <li>Total Orphaned Nodes: 100</li> </ul> <p>Concepts that are not prerequisites for any other concept:</p> <ul> <li>5: OLAP</li> <li>6: OLTP</li> <li>8: Key-Value Stores</li> <li>10: Wide-Column Stores</li> <li>13: Tradeoff Analysis</li> <li>20: Normalization</li> <li>35: Constant-Time Neighbor Access</li> <li>36: First-Class Relationships</li> <li>40: Metadata Representation</li> <li>41: Open World Model</li> <li>42: Closed World Model</li> <li>44: Document Validation</li> <li>48: Statistical Query Tuning</li> <li>52: Where Clause</li> <li>53: Return Clause</li> <li>55: Merge Statement</li> <li>56: Delete Statement</li> <li>57: Set Clause</li> <li>58: Graph Patterns</li> <li>61: All Paths</li> </ul> <p>...and 80 more</p>"},{"location":"learning-graph/quality-metrics/#connected-components","title":"Connected Components","text":"<ul> <li>Number of Connected Components: 1</li> </ul> <p>\u2705 All concepts are connected in a single graph.</p>"},{"location":"learning-graph/quality-metrics/#indegree-analysis","title":"Indegree Analysis","text":"<p>Top 10 concepts that are prerequisites for the most other concepts:</p> Rank Concept ID Concept Label Indegree 1 21 Labeled Property Graph 23 2 23 Edges 18 3 22 Nodes 12 4 38 Graph Data Model 11 5 24 Properties 10 6 29 Traversal 9 7 30 Graph Query 9 8 37 Edge Direction 9 9 50 Cypher Syntax 8 10 111 Social Networks 8"},{"location":"learning-graph/quality-metrics/#outdegree-distribution","title":"Outdegree Distribution","text":"Dependencies Number of Concepts 0 6 1 85 2 96 3 11 5 1 6 1"},{"location":"learning-graph/quality-metrics/#recommendations","title":"Recommendations","text":"<ul> <li>\u26a0\ufe0f Many orphaned nodes (100): Consider if these should be prerequisites for advanced concepts</li> <li>\u2139\ufe0f Long dependency chains (18): Ensure students can follow extended learning paths</li> </ul> <p>Report generated by learning-graph-reports/analyze_graph.py</p>"},{"location":"learning-graph/taxonomy-distribution/","title":"Taxonomy Distribution Report","text":""},{"location":"learning-graph/taxonomy-distribution/#overview","title":"Overview","text":"<ul> <li>Total Concepts: 200</li> <li>Number of Taxonomies: 12</li> <li>Average Concepts per Taxonomy: 16.7</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#distribution-summary","title":"Distribution Summary","text":"Category TaxonomyID Count Percentage Status GRAPH GRAPH 42 21.0% \u2705 QUERY QUERY 26 13.0% \u2705 Foundation Concepts - Prerequisites FOUND 25 12.5% \u2705 ALGO ALGO 17 8.5% \u2705 SUPPLY SUPPLY 16 8.0% \u2705 PERF PERF 15 7.5% \u2705 SOCIAL SOCIAL 15 7.5% \u2705 PATTERN PATTERN 15 7.5% \u2705 KNOW KNOW 10 5.0% \u2705 Advanced Topics ADV 10 5.0% \u2705 FIN FIN 5 2.5% \u2139\ufe0f Under HEALTH HEALTH 4 2.0% \u2139\ufe0f Under"},{"location":"learning-graph/taxonomy-distribution/#visual-distribution","title":"Visual Distribution","text":"<pre><code>GRAPH  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  42 ( 21.0%)\nQUERY  \u2588\u2588\u2588\u2588\u2588\u2588  26 ( 13.0%)\nFOUND  \u2588\u2588\u2588\u2588\u2588\u2588  25 ( 12.5%)\nALGO   \u2588\u2588\u2588\u2588  17 (  8.5%)\nSUPPLY \u2588\u2588\u2588\u2588  16 (  8.0%)\nPERF   \u2588\u2588\u2588  15 (  7.5%)\nSOCIAL \u2588\u2588\u2588  15 (  7.5%)\nPATTERN \u2588\u2588\u2588  15 (  7.5%)\nKNOW   \u2588\u2588  10 (  5.0%)\nADV    \u2588\u2588  10 (  5.0%)\nFIN    \u2588   5 (  2.5%)\nHEALTH \u2588   4 (  2.0%)\n</code></pre>"},{"location":"learning-graph/taxonomy-distribution/#balance-analysis","title":"Balance Analysis","text":""},{"location":"learning-graph/taxonomy-distribution/#no-over-represented-categories","title":"\u2705 No Over-Represented Categories","text":"<p>All categories are under the 30% threshold. Good balance!</p>"},{"location":"learning-graph/taxonomy-distribution/#i-under-represented-categories-3","title":"\u2139\ufe0f Under-Represented Categories (&lt;3%)","text":"<ul> <li>FIN (FIN): 5 concepts (2.5%)</li> <li>Note: Small categories are acceptable for specialized topics</li> <li>HEALTH (HEALTH): 4 concepts (2.0%)</li> <li>Note: Small categories are acceptable for specialized topics</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#category-details","title":"Category Details","text":""},{"location":"learning-graph/taxonomy-distribution/#graph-graph","title":"GRAPH (GRAPH)","text":"<p>Count: 42 concepts (21.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Labeled Property Graph</li> </ol> </li> <li> <ol> <li>Nodes</li> </ol> </li> <li> <ol> <li>Edges</li> </ol> </li> <li> <ol> <li>Properties</li> </ol> </li> <li> <ol> <li>Labels</li> </ol> </li> <li> <ol> <li>Schema-Optional Modeling</li> </ol> </li> <li> <ol> <li>Schema-Enforced Modeling</li> </ol> </li> <li> <ol> <li>Index-Free Adjacency</li> </ol> </li> <li> <ol> <li>Traversal</li> </ol> </li> <li> <ol> <li>Graph Query</li> </ol> </li> <li> <ol> <li>Pattern Matching</li> </ol> </li> <li> <ol> <li>Multi-Hop Queries</li> </ol> </li> <li> <ol> <li>Aggregation</li> </ol> </li> <li> <ol> <li>Path Patterns</li> </ol> </li> <li> <ol> <li>Constant-Time Neighbor Access</li> </ol> </li> <li>...and 27 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#query-query","title":"QUERY (QUERY)","text":"<p>Count: 26 concepts (13.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>OpenCypher</li> </ol> </li> <li> <ol> <li>GSQL</li> </ol> </li> <li> <ol> <li>Statistical Query Tuning</li> </ol> </li> <li> <ol> <li>GQL</li> </ol> </li> <li> <ol> <li>Cypher Syntax</li> </ol> </li> <li> <ol> <li>Match Clause</li> </ol> </li> <li> <ol> <li>Where Clause</li> </ol> </li> <li> <ol> <li>Return Clause</li> </ol> </li> <li> <ol> <li>Create Statement</li> </ol> </li> <li> <ol> <li>Merge Statement</li> </ol> </li> <li> <ol> <li>Delete Statement</li> </ol> </li> <li> <ol> <li>Set Clause</li> </ol> </li> <li> <ol> <li>Graph Patterns</li> </ol> </li> <li> <ol> <li>Variable Length Paths</li> </ol> </li> <li> <ol> <li>Shortest Path</li> </ol> </li> <li>...and 11 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#foundation-concepts-prerequisites-found","title":"Foundation Concepts - Prerequisites (FOUND)","text":"<p>Count: 25 concepts (12.5%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Data Modeling</li> </ol> </li> <li> <ol> <li>World Models</li> </ol> </li> <li> <ol> <li>Knowledge Representation</li> </ol> </li> <li> <ol> <li>RDBMS</li> </ol> </li> <li> <ol> <li>OLAP</li> </ol> </li> <li> <ol> <li>OLTP</li> </ol> </li> <li> <ol> <li>NoSQL Databases</li> </ol> </li> <li> <ol> <li>Key-Value Stores</li> </ol> </li> <li> <ol> <li>Document Databases</li> </ol> </li> <li> <ol> <li>Wide-Column Stores</li> </ol> </li> <li> <ol> <li>Graph Databases</li> </ol> </li> <li> <ol> <li>CAP Theorem</li> </ol> </li> <li> <ol> <li>Tradeoff Analysis</li> </ol> </li> <li> <ol> <li>Schema Design</li> </ol> </li> <li> <ol> <li>Hash Maps</li> </ol> </li> <li>...and 10 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#algo-algo","title":"ALGO (ALGO)","text":"<p>Count: 17 concepts (8.5%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Breadth-First Search</li> </ol> </li> <li> <ol> <li>Depth-First Search</li> </ol> </li> <li> <ol> <li>A-Star Algorithm</li> </ol> </li> <li> <ol> <li>Pathfinding</li> </ol> </li> <li> <ol> <li>Traveling Salesman Problem</li> </ol> </li> <li> <ol> <li>PageRank</li> </ol> </li> <li> <ol> <li>Community Detection</li> </ol> </li> <li> <ol> <li>Centrality Measures</li> </ol> </li> <li> <ol> <li>Betweenness Centrality</li> </ol> </li> <li> <ol> <li>Closeness Centrality</li> </ol> </li> <li> <ol> <li>Graph Embeddings</li> </ol> </li> <li> <ol> <li>Graph Neural Networks</li> </ol> </li> <li> <ol> <li>Link Prediction</li> </ol> </li> <li> <ol> <li>Graph Clustering</li> </ol> </li> <li> <ol> <li>Connected Components</li> </ol> </li> <li>...and 2 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#supply-supply","title":"SUPPLY (SUPPLY)","text":"<p>Count: 16 concepts (8.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Web Storefront Models</li> </ol> </li> <li> <ol> <li>Product Catalogs</li> </ol> </li> <li> <ol> <li>Recommendation Engines</li> </ol> </li> <li> <ol> <li>Bill of Materials</li> </ol> </li> <li> <ol> <li>Complex Parts</li> </ol> </li> <li> <ol> <li>Supply Chain Modeling</li> </ol> </li> <li> <ol> <li>IT Asset Management</li> </ol> </li> <li> <ol> <li>Dependency Graphs</li> </ol> </li> <li> <ol> <li>Network Topology</li> </ol> </li> <li> <ol> <li>Configuration Management</li> </ol> </li> <li> <ol> <li>Impact Analysis</li> </ol> </li> <li> <ol> <li>Root Cause Analysis</li> </ol> </li> <li> <ol> <li>Regulatory Compliance</li> </ol> </li> <li> <ol> <li>Data Lineage</li> </ol> </li> <li> <ol> <li>Master Data Management</li> </ol> </li> <li>...and 1 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#perf-perf","title":"PERF (PERF)","text":"<p>Count: 15 concepts (7.5%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Hop Count</li> </ol> </li> <li> <ol> <li>Indegree</li> </ol> </li> <li> <ol> <li>Outdegree</li> </ol> </li> <li> <ol> <li>Graph Indexes</li> </ol> </li> <li> <ol> <li>Vector Indexes</li> </ol> </li> <li> <ol> <li>Full-Text Search</li> </ol> </li> <li> <ol> <li>Composite Indexes</li> </ol> </li> <li> <ol> <li>Graph Metrics</li> </ol> </li> <li> <ol> <li>Performance Benchmarking</li> </ol> </li> <li> <ol> <li>Synthetic Benchmarks</li> </ol> </li> <li> <ol> <li>LDBC SNB Benchmark</li> </ol> </li> <li> <ol> <li>Graph 500</li> </ol> </li> <li> <ol> <li>Query Cost Analysis</li> </ol> </li> <li> <ol> <li>Join Operations</li> </ol> </li> <li> <ol> <li>Scalability</li> </ol> </li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#social-social","title":"SOCIAL (SOCIAL)","text":"<p>Count: 15 concepts (7.5%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Social Networks</li> </ol> </li> <li> <ol> <li>Friend Graphs</li> </ol> </li> <li> <ol> <li>Influence Graphs</li> </ol> </li> <li> <ol> <li>Follower Networks</li> </ol> </li> <li> <ol> <li>Activity Streams</li> </ol> </li> <li> <ol> <li>User Profiles</li> </ol> </li> <li> <ol> <li>Relationship Types</li> </ol> </li> <li> <ol> <li>Sentiment Analysis</li> </ol> </li> <li> <ol> <li>Natural Language Processing</li> </ol> </li> <li> <ol> <li>Fake Account Detection</li> </ol> </li> <li> <ol> <li>Human Resources Modeling</li> </ol> </li> <li> <ol> <li>Org Chart Models</li> </ol> </li> <li> <ol> <li>Skill Management</li> </ol> </li> <li> <ol> <li>Task Assignment</li> </ol> </li> <li> <ol> <li>Backlog Management</li> </ol> </li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#pattern-pattern","title":"PATTERN (PATTERN)","text":"<p>Count: 15 concepts (7.5%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Subgraphs</li> </ol> </li> <li> <ol> <li>Anti-Patterns</li> </ol> </li> <li> <ol> <li>Time-Based Modeling</li> </ol> </li> <li> <ol> <li>IoT Event Modeling</li> </ol> </li> <li> <ol> <li>Bitemporal Models</li> </ol> </li> <li> <ol> <li>Graph Quality Metrics</li> </ol> </li> <li> <ol> <li>Model Validation</li> </ol> </li> <li> <ol> <li>Schema Evolution</li> </ol> </li> <li> <ol> <li>Data Migration</li> </ol> </li> <li> <ol> <li>ETL Pipelines</li> </ol> </li> <li> <ol> <li>CSV Import</li> </ol> </li> <li> <ol> <li>JSON Import</li> </ol> </li> <li> <ol> <li>Data Loading</li> </ol> </li> <li> <ol> <li>Bulk Loading</li> </ol> </li> <li> <ol> <li>Incremental Loading</li> </ol> </li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#know-know","title":"KNOW (KNOW)","text":"<p>Count: 10 concepts (5.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Concept Dependency Graphs</li> </ol> </li> <li> <ol> <li>Curriculum Graphs</li> </ol> </li> <li> <ol> <li>Ontologies</li> </ol> </li> <li> <ol> <li>SKOS</li> </ol> </li> <li> <ol> <li>Acronym Lists</li> </ol> </li> <li> <ol> <li>Glossaries</li> </ol> </li> <li> <ol> <li>Controlled Vocabularies</li> </ol> </li> <li> <ol> <li>Taxonomies</li> </ol> </li> <li> <ol> <li>Note-Taking Systems</li> </ol> </li> <li> <ol> <li>Action Item Extraction</li> </ol> </li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#advanced-topics-adv","title":"Advanced Topics (ADV)","text":"<p>Count: 10 concepts (5.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Distributed Graph Databases</li> </ol> </li> <li> <ol> <li>Graph Partitioning</li> </ol> </li> <li> <ol> <li>Sharding Strategies</li> </ol> </li> <li> <ol> <li>Replication</li> </ol> </li> <li> <ol> <li>Consistency Models</li> </ol> </li> <li> <ol> <li>Graph Visualization</li> </ol> </li> <li> <ol> <li>Interactive Queries</li> </ol> </li> <li> <ol> <li>Real-Time Analytics</li> </ol> </li> <li> <ol> <li>Batch Processing</li> </ol> </li> <li> <ol> <li>Capstone Project Design</li> </ol> </li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#fin-fin","title":"FIN (FIN)","text":"<p>Count: 5 concepts (2.5%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Financial Transactions</li> </ol> </li> <li> <ol> <li>Fraud Detection</li> </ol> </li> <li> <ol> <li>Anti-Money Laundering</li> </ol> </li> <li> <ol> <li>Know Your Customer</li> </ol> </li> <li> <ol> <li>Account Networks</li> </ol> </li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#health-health","title":"HEALTH (HEALTH)","text":"<p>Count: 4 concepts (2.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Healthcare Graphs</li> </ol> </li> <li> <ol> <li>Provider-Patient Graphs</li> </ol> </li> <li> <ol> <li>Electronic Health Records</li> </ol> </li> <li> <ol> <li>Clinical Pathways</li> </ol> </li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#recommendations","title":"Recommendations","text":"<ul> <li>\u2705 Good balance: Categories are reasonably distributed (spread: 19.0%)</li> <li>\u2705 MISC category minimal: Good categorization specificity</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#educational-use-recommendations","title":"Educational Use Recommendations","text":"<ul> <li>Use taxonomy categories for color-coding in graph visualizations</li> <li>Design curriculum modules based on taxonomy groupings</li> <li>Create filtered views for focused learning paths</li> <li>Use categories for assessment organization</li> <li>Enable navigation by topic area in interactive tools</li> </ul> <p>Report generated by learning-graph-reports/taxonomy_distribution.py</p>"},{"location":"notes/knowledge-types/","title":"Knowledge Types","text":""},{"location":"notes/knowledge-types/#tacit-knowledge","title":"Tacit Knowledge","text":"<p>Definition: Tacit knowledge is the internal, experiential, intuitive, and often subconscious knowledge that people gain through direct experience, observation, and practice. It is difficult to write down, formalize, or express explicitly. Tacit knowledge often includes insights, mental models, pattern recognition, motor skills, and \"know-how\" gained from doing rather than reading.</p> <p>Tacit knowledge is personal, context-dependent, and hard to transfer except through mentoring, apprenticeship, demonstration, or immersion.</p> <p>Characteristics:</p> <ul> <li> <p>Hard to articulate</p> </li> <li> <p>Learned experientially</p> </li> <li> <p>Stored in mental models</p> </li> <li> <p>Influenced by intuition</p> </li> <li> <p>Shared through demonstration (\"watch me do it\")</p> </li> <li> <p>Cannot be fully captured in text or rules</p> </li> </ul> <p>Examples:</p> <ul> <li> <p>Knowing how to ride a bicycle</p> </li> <li> <p>An engineer's intuition about where a system will fail</p> </li> <li> <p>A doctor recognizing subtle diagnostic cues in a patient</p> </li> <li> <p>A teacher sensing when a student is confused</p> </li> <li> <p>A chef adjusting seasoning \"by feel\"</p> </li> </ul>"},{"location":"notes/knowledge-types/#codifiable-codified-knowledge","title":"Codifiable (Codified) Knowledge","text":"<p>Definition: Codifiable knowledge (also called explicit knowledge) is knowledge that can be written down, structured, formalized, stored, indexed, and transmitted using language, symbols, diagrams, or algorithms. It can be represented digitally or in print and is suitable for search, retrieval, and encoding into knowledge graphs.</p> <p>Codifiable knowledge is systematic, transferable, and independent of the person who originally discovered it.</p> <p>Characteristics:</p> <ul> <li> <p>Easy to articulate</p> </li> <li> <p>Can be stored in documents, code, formulas, or graphs</p> </li> <li> <p>Transferable at scale</p> </li> <li> <p>Can be indexed and searched</p> </li> <li> <p>Basis of textbooks, training materials, and rules engines</p> </li> </ul> <p>Examples:</p> <ul> <li> <p>Mathematical formulas</p> </li> <li> <p>SQL or GSQL queries</p> </li> <li> <p>Step-by-step procedural instructions</p> </li> <li> <p>Engineering design rules</p> </li> <li> <p>Scientific facts</p> </li> <li> <p>Curriculum standards</p> </li> <li> <p>Concept dependency graphs</p> </li> <li> <p>Documentation and APIs</p> </li> </ul>"},{"location":"notes/knowledge-types/#relationship-to-learning-graphs-and-ai-enhanced-textbooks","title":"Relationship to Learning Graphs and AI-Enhanced Textbooks","text":"<p>These two knowledge types align beautifully with your Learning Graph framework:</p>"},{"location":"notes/knowledge-types/#tacit-knowledge_1","title":"Tacit Knowledge","text":"<ul> <li> <p>Appears as cognitive strategies</p> </li> <li> <p>Represented indirectly in skills, heuristics, hints, or coaching tips</p> </li> <li> <p>Transferred through MicroSims, demonstrations, feedback loops, or expert modeling</p> </li> </ul>"},{"location":"notes/knowledge-types/#codifiable-knowledge","title":"Codifiable Knowledge","text":"<ul> <li> <p>Appears directly as concept nodes, definitions, procedures, and rules</p> </li> <li> <p>Easily structured into LPG databases, curriculum graphs, and AI-searchable knowledge stores</p> </li> <li> <p>Forms the core of intelligent textbooks</p> </li> </ul>"},{"location":"notes/knowledge-types/#why-this-matters-for-your-work","title":"Why This Matters for Your Work","text":"<p>Your textbooks and MicroSims can explicitly separate:</p> <ul> <li> <p>Codifiable knowledge: the teachable content (facts, models, diagrams, rules).</p> </li> <li> <p>Tacit knowledge: the experiential \"feel\" of mastery, supported through</p> <ul> <li> <p>simulations</p> </li> <li> <p>decision-making scenarios</p> </li> <li> <p>guided practice</p> </li> <li> <p>reflective prompts</p> </li> <li> <p>worked examples</p> </li> </ul> </li> </ul> <p>This division supports your design principle that graph-encoded knowledge handles the explicit layer, while simulations and interactive examples provide the bridge to tacit mastery.</p>"},{"location":"sims/graph-viewer/","title":"Learning Graph Viewer","text":"<p>Run the Learning Graph Viewer</p> <p>This viewer reads a learning graph data from ../../learning-graph/learning-graph.json:</p> <ol> <li>Search Functionality - Quick node lookup with autocomplete</li> <li>Taxonomy Legend Controls - Filter nodes by category/taxonomy</li> </ol>"},{"location":"sims/graph-viewer/#features","title":"Features","text":""},{"location":"sims/graph-viewer/#search","title":"Search","text":"<ul> <li>Type-ahead search for node names</li> <li>Displays matching results in a dropdown</li> <li>Shows node group/category in results</li> <li>Clicking a result focuses and highlights the node on the graph</li> <li>Only searches visible nodes (respects taxonomy filters)</li> </ul>"},{"location":"sims/graph-viewer/#taxonomy-legend-with-checkboxes","title":"Taxonomy Legend with Checkboxes","text":"<ul> <li>Sidebar legend with all node categories</li> <li>Toggle visibility of entire node groups</li> <li>Color-coded categories matching the graph</li> <li>\"Check All\" and \"Uncheck All\" buttons for bulk operations</li> <li>Collapsible sidebar to maximize graph viewing area</li> </ul>"},{"location":"sims/graph-viewer/#graph-statistics","title":"Graph Statistics","text":"<p>Real-time statistics that update as you filter: - Nodes: Count of visible nodes - Edges: Count of visible edges (both endpoints must be visible) - Orphans: Nodes with no connections (this is an indication that the learning graph needs editing)</p>"},{"location":"sims/graph-viewer/#sample-graph-demo","title":"Sample Graph Demo","text":"<p>The demo includes a Graph Theory learning graph with 10 taxonomy categories:</p> <ul> <li>Foundation (Red) - Core concepts in red boxes that should be pinned to the left</li> <li>Types (Orange) - Graph types</li> <li>Representations (Gold) - Data structures</li> <li>Algorithms (Green) - Basic algorithms</li> <li>Paths (Blue) - Shortest path algorithms</li> <li>Flow (Indigo) - Network flow algorithms</li> <li>Advanced (Violet) - Advanced topics</li> <li>Metrics (Gray) - Centrality measures</li> <li>Spectral (Brown) - Spectral theory</li> <li>ML &amp; Networks (Teal) - Machine learning</li> </ul>"},{"location":"sims/graph-viewer/#usage-tips","title":"Usage Tips","text":"<ol> <li>Hide a category - Uncheck a category in the sidebar to hide all nodes in that group</li> <li>Search within visible nodes - Use search to quickly find specific concepts among visible nodes</li> <li>Focus on a topic - Uncheck all categories, then check only the ones you want to study</li> <li>Collapse sidebar - Click the menu button (\u2630) to hide the sidebar and expand the graph view</li> <li>Find orphans - Check the statistics to see if any nodes lack connections</li> </ol>"},{"location":"sims/graph-viewer/#implementation-notes","title":"Implementation Notes","text":"<p>This viewer follows the standard vis.js architectural patterns:</p> <ul> <li>Uses <code>vis.DataSet</code> for nodes and edges</li> <li>Implements node <code>hidden</code> property for filtering</li> <li>Combines separate search and legend features</li> <li>Updates statistics dynamically based on visibility</li> <li>Maintains consistent styling across features</li> </ul>"},{"location":"sims/graph-viewer/#use-cases","title":"Use Cases","text":"<ul> <li>Course planning - Filter by topic area to design lesson sequences</li> <li>Concept exploration - Search for specific concepts and see their dependencies</li> <li>Gap analysis - Use orphan count to identify disconnected concepts</li> <li>Progressive learning - Start with foundation concepts, gradually enable advanced topics</li> </ul>"},{"location":"sims/minimum-spanning-tree/","title":"Minimum Spanning Tree Algorithm Visualizer","text":"<p>Run the Minimum Spanning Tree MicroSim Fullscreen</p> <p>You can include this MicroSim on your website using the following <code>iframe</code>:</p> <pre><code>&lt;iframe src=\"https://dmccreary.github.io/intro-to-graph/sims/minimum-spanning-tree/main.html\"\n        height=\"652px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;\n&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/minimum-spanning-tree/#description","title":"Description","text":"<p>The Minimum Spanning Tree (MST) MicroSim provides an interactive visualization of two fundamental graph algorithms: Kruskal's algorithm and Prim's algorithm. Both algorithms solve the same problem\u2014finding the minimum cost network that connects all nodes without creating cycles\u2014but use different strategic approaches.</p>"},{"location":"sims/minimum-spanning-tree/#what-is-a-minimum-spanning-tree","title":"What is a Minimum Spanning Tree?","text":"<p>A minimum spanning tree is a subset of edges in a weighted graph that: - Connects all nodes (vertices) together - Contains no cycles (is a tree structure) - Minimizes the total edge weight (has minimum total cost)</p> <p>MSTs solve critical real-world problems in network design, infrastructure planning, and optimization.</p>"},{"location":"sims/minimum-spanning-tree/#algorithm-comparison","title":"Algorithm Comparison","text":"<p>Kruskal's Algorithm (Edge-Based Greedy Approach): - Sorts all edges by weight from smallest to largest - Examines edges in order, adding each edge if it doesn't create a cycle - Uses a union-find data structure to detect cycles efficiently - Strategy: \"Consider the cheapest available connection\"</p> <p>Prim's Algorithm (Node-Based Greedy Approach): - Starts from an arbitrary node and grows the tree one node at a time - Always adds the minimum-weight edge connecting a visited node to an unvisited node - Uses a priority queue to track candidate edges - Strategy: \"Expand the tree with the cheapest connection to a new location\"</p>"},{"location":"sims/minimum-spanning-tree/#visual-feedback","title":"Visual Feedback","text":"<p>The simulation uses color coding to show algorithm progress: - Gray edges: Available for consideration - Yellow edge: Currently being evaluated - Gold edges: Accepted into the MST (thick lines) - Light gray edges: Rejected (would create cycle) - Green nodes (Prim's only): Visited nodes included in the MST</p> <p>Edge weights are displayed at the midpoint of each edge in white circles for easy reference.</p>"},{"location":"sims/minimum-spanning-tree/#interactive-controls","title":"Interactive Controls","text":"<p>Algorithm Selection: - Dropdown menu to switch between Kruskal's and Prim's algorithms - Changing algorithms resets the simulation with a new random graph</p> <p>Execution Controls: - Step Forward: Execute one algorithm step to see detailed decision-making - Auto Run: Animate the complete algorithm execution - Reset: Generate a new random graph and restart</p> <p>Animation Speed: - Slider controls the delay between steps (100-2000 milliseconds) - Slower speeds help understand each decision; faster speeds show overall behavior</p> <p>Status Display: - Current action description explains each step - Edge counter shows progress (current/total edges needed) - Running total displays cumulative MST weight</p>"},{"location":"sims/minimum-spanning-tree/#educational-applications","title":"Educational Applications","text":""},{"location":"sims/minimum-spanning-tree/#learning-objectives","title":"Learning Objectives","text":"<p>Students using this MicroSim will: 1. Understand the minimum spanning tree problem and its real-world applications 2. Compare two different algorithmic approaches to the same problem 3. Analyze how greedy algorithms make locally optimal choices 4. Observe cycle detection mechanisms in action 5. Apply graph theory concepts to network optimization</p>"},{"location":"sims/minimum-spanning-tree/#classroom-activities","title":"Classroom Activities","text":"<p>Activity 1: Algorithm Comparison - Run both algorithms on the same graph (use Reset to generate new graphs) - Verify that both produce MSTs with the same total weight - Observe how the order of edge selection differs between algorithms - Discuss: Why do different approaches yield the same optimal result?</p> <p>Activity 2: Manual Prediction - Pause after each step and predict which edge will be selected next - For Kruskal's: Find the minimum weight edge that won't create a cycle - For Prim's: Find the minimum weight edge connecting to an unvisited node - Verify predictions by stepping forward</p> <p>Activity 3: Real-World Applications - Given the graph represents cities connected by roads, what does the MST represent?   - Answer: Minimum road network connecting all cities - Brainstorm other scenarios: utility networks, computer networks, transportation routes - Calculate potential cost savings: Compare MST weight to total graph weight</p> <p>Activity 4: Cycle Detection - Watch carefully when Kruskal's rejects edges - Identify which existing MST edges would create a cycle with the rejected edge - Understand why preventing cycles is essential for tree structures</p>"},{"location":"sims/minimum-spanning-tree/#discussion-questions","title":"Discussion Questions","text":"<ol> <li>Why do both algorithms always find an MST with the same total weight, even though they select edges in different orders?</li> <li>In what situations might you prefer Kruskal's algorithm over Prim's (or vice versa)?</li> <li>How does the union-find data structure enable efficient cycle detection in Kruskal's algorithm?</li> <li>What would happen if edges had negative weights? Would these algorithms still work?</li> <li>Can you think of situations where you'd want the maximum spanning tree instead?</li> </ol>"},{"location":"sims/minimum-spanning-tree/#real-world-applications","title":"Real-World Applications","text":""},{"location":"sims/minimum-spanning-tree/#network-infrastructure-design","title":"Network Infrastructure Design","text":"<ul> <li>Telecommunications: Laying fiber optic cable to connect cities with minimum total length</li> <li>Electrical grids: Connecting power stations with minimum transmission line cost</li> <li>Water distribution: Designing pipe networks to serve all locations efficiently</li> </ul>"},{"location":"sims/minimum-spanning-tree/#computer-networks","title":"Computer Networks","text":"<ul> <li>Local Area Networks (LANs): Minimizing cable length in building networks</li> <li>Network routing: Finding efficient data transmission paths</li> <li>Cluster analysis: Grouping similar data points with minimum total distance</li> </ul>"},{"location":"sims/minimum-spanning-tree/#transportation-and-logistics","title":"Transportation and Logistics","text":"<ul> <li>Road networks: Connecting communities with minimum pavement</li> <li>Railway planning: Designing rail lines connecting stations</li> <li>Airline route optimization: Hub-and-spoke network design</li> </ul>"},{"location":"sims/minimum-spanning-tree/#supply-chain-management","title":"Supply Chain Management","text":"<ul> <li>Distribution centers: Connecting warehouses with minimum shipping cost</li> <li>Pipeline networks: Oil, gas, or water pipeline routing</li> <li>Manufacturing: Connecting assembly stations on a factory floor</li> </ul>"},{"location":"sims/minimum-spanning-tree/#technical-implementation","title":"Technical Implementation","text":"<p>This MicroSim is built with p5.js and follows educational MicroSim design standards: - Width-responsive: Adapts to any container width while maintaining proportions - Clean separation: Drawing area (graph) separate from control area (UI) - Immediate feedback: Real-time visualization of algorithm decisions - Educational focus: Clear labels, status messages, and visual differentiation</p>"},{"location":"sims/minimum-spanning-tree/#data-structures-used","title":"Data Structures Used","text":"<p>Graph Representation: - Nodes: Array of objects with position and label - Edges: Array of objects with endpoints, weight, and state</p> <p>Kruskal's Algorithm: - Sorted edge list (priority queue) - Union-find (disjoint set) for cycle detection</p> <p>Prim's Algorithm: - Visited node tracker (boolean array) - Priority queue of candidate edges</p>"},{"location":"sims/minimum-spanning-tree/#algorithm-complexity","title":"Algorithm Complexity","text":"<p>Both algorithms have similar time complexity: - Kruskal's: O(E log E) where E = number of edges (dominated by sorting) - Prim's: O(E log V) where V = number of nodes (with binary heap priority queue)</p> <p>For dense graphs (many edges), Prim's can be more efficient. For sparse graphs (few edges), Kruskal's may perform better in practice.</p>"},{"location":"sims/minimum-spanning-tree/#extension-ideas","title":"Extension Ideas","text":"<p>Teachers and advanced students can extend this simulation:</p> <ol> <li>Compare performance: Add a step counter to compare how many steps each algorithm requires</li> <li>Show the queue: Display Kruskal's sorted edge list or Prim's priority queue</li> <li>Weight visualization: Use edge thickness to represent weight visually</li> <li>Custom graphs: Allow students to create their own graphs by clicking to add nodes/edges</li> <li>Maximum spanning tree: Modify algorithms to find maximum instead of minimum weight</li> <li>Animation effects: Add particle flow along edges to show \"network traffic\"</li> </ol>"},{"location":"sims/minimum-spanning-tree/#lesson-plan","title":"Lesson Plan","text":"<p>Grade Level: High School (Grades 10-12) or Undergraduate Computer Science</p> <p>Duration: 45-60 minutes</p> <p>Prerequisites: - Understanding of graphs (nodes and edges) - Basic algorithm concepts - Familiarity with greedy algorithms (helpful but not required)</p> <p>Learning Sequence:</p> <ol> <li>Introduction (10 min)</li> <li>Define minimum spanning tree problem</li> <li>Discuss real-world applications</li> <li> <p>Introduce greedy algorithm concept</p> </li> <li> <p>Guided Exploration (15 min)</p> </li> <li>Demonstrate Kruskal's algorithm using Step Forward</li> <li>Students predict next edge selection</li> <li> <p>Discuss cycle detection mechanism</p> </li> <li> <p>Algorithm Comparison (10 min)</p> </li> <li>Show Prim's algorithm on same graph</li> <li>Compare edge selection order</li> <li> <p>Verify both find same total weight</p> </li> <li> <p>Independent Practice (10 min)</p> </li> <li>Students experiment with both algorithms</li> <li>Try different animation speeds</li> <li> <p>Generate multiple random graphs</p> </li> <li> <p>Application Discussion (10 min)</p> </li> <li>Brainstorm real-world MST problems</li> <li>Discuss when each algorithm might be preferred</li> <li> <p>Connect to broader graph theory concepts</p> </li> <li> <p>Assessment (5 min)</p> </li> <li>Quiz: Given a small graph, manually find the MST</li> <li>Verify answer using the simulation</li> </ol> <p>Assessment Opportunities: - Can students correctly predict which edge will be selected next? - Do students understand why certain edges are rejected? - Can students explain the difference between the two algorithmic approaches? - Can students identify real-world applications of MSTs?</p>"},{"location":"sims/minimum-spanning-tree/#related-concepts","title":"Related Concepts","text":"<ul> <li>Graph theory fundamentals</li> <li>Greedy algorithms</li> <li>Union-find (disjoint set) data structure</li> <li>Priority queues and heaps</li> <li>Network optimization</li> <li>Computational complexity</li> <li>NP-completeness (MST is actually in P, unlike many graph problems)</li> </ul>"},{"location":"sims/minimum-spanning-tree/#references","title":"References","text":"<ol> <li> <p>Kruskal, J. B. (1956). \"On the shortest spanning subtree of a graph and the traveling salesman problem\". Proceedings of the American Mathematical Society, 7(1), 48-50.</p> </li> <li> <p>Prim, R. C. (1957). \"Shortest connection networks and some generalizations\". Bell System Technical Journal, 36(6), 1389-1401.</p> </li> <li> <p>Cormen, T. H., Leiserson, C. E., Rivest, R. L., &amp; Stein, C. (2009). Introduction to Algorithms (3rd ed.). MIT Press. Chapter 23: Minimum Spanning Trees.</p> </li> </ol>"},{"location":"sims/multi-hop-comparison/","title":"Query Performance Comparison: RDBMS vs Graph Database","text":"<p>This interactive Chart.js visualization demonstrates the dramatic performance differences between relational databases using JOIN operations and graph databases using index-free adjacency for multi-hop relationship queries in healthcare data systems.</p>"},{"location":"sims/multi-hop-comparison/#interactive-chart","title":"Interactive Chart","text":"<p>View Fullscreen</p> <pre><code>&lt;iframe src=\"main.html\" width=\"100%\" height=\"550\" scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/multi-hop-comparison/#overview","title":"Overview","text":"<p>This line chart compares query response times between traditional relational database management systems (RDBMS) and graph databases as the number of relationship hops increases. The visualization uses a logarithmic Y-axis to effectively display the exponential performance degradation of RDBMS JOIN operations compared to the near-constant performance of graph database traversals.</p>"},{"location":"sims/multi-hop-comparison/#key-findings","title":"Key Findings","text":"<p>The chart reveals three critical insights:</p> <ol> <li> <p>Exponential RDBMS Degradation: Relational databases experience exponential performance degradation as relationship depth increases. A 5-hop query takes over 14 minutes (850,000ms), making it impractical for real-time healthcare applications.</p> </li> <li> <p>Linear Graph DB Performance: Graph databases maintain near-constant query times, increasing only slightly from 3ms (1 hop) to 17ms (6 hops), demonstrating O(1) traversal characteristics.</p> </li> <li> <p>Performance Gap: At 5 relationship hops, graph databases are approximately 60,000 times faster than relational databases for the same query.</p> </li> </ol>"},{"location":"sims/multi-hop-comparison/#features","title":"Features","text":""},{"location":"sims/multi-hop-comparison/#interactive-elements","title":"Interactive Elements","text":"<ul> <li>Hover Tooltips: Hover over data points to see exact query times formatted in appropriate units (milliseconds, seconds, or minutes)</li> <li>Clickable Legend: Click legend items to show/hide specific datasets for focused analysis</li> <li>Smooth Animations: Chart animates on load to emphasize the performance differences</li> <li>Annotations: Built-in labels highlight key insights directly on the chart</li> </ul>"},{"location":"sims/multi-hop-comparison/#visual-design","title":"Visual Design","text":"<ul> <li>Logarithmic Scale: Y-axis uses logarithmic scaling to effectively display values ranging from 1ms to 850,000ms</li> <li>Color Coding: Red for RDBMS (danger/slow), green for Graph DB (success/fast)</li> <li>Distinct Markers: Square markers for RDBMS, circular markers for Graph DB</li> <li>Grid Lines: Clear grid lines at powers of 10 for easy reading</li> <li>Responsive Layout: Adapts to different screen sizes while maintaining readability</li> </ul>"},{"location":"sims/multi-hop-comparison/#understanding-the-chart","title":"Understanding the Chart","text":""},{"location":"sims/multi-hop-comparison/#x-axis-relationship-hops","title":"X-Axis: Relationship Hops","text":"<p>The X-axis represents the depth of relationship traversals:</p> <ul> <li>1 hop: Direct relationships (e.g., Patient \u2192 Diagnosis)</li> <li>2 hops: Second-degree relationships (e.g., Patient \u2192 Diagnosis \u2192 Treatment)</li> <li>3 hops: Third-degree relationships (e.g., Patient \u2192 Diagnosis \u2192 Treatment \u2192 Medication)</li> <li>4+ hops: Deep relationship chains common in complex healthcare dependency analysis</li> </ul>"},{"location":"sims/multi-hop-comparison/#y-axis-response-time-logarithmic","title":"Y-Axis: Response Time (Logarithmic)","text":"<p>The Y-axis shows query response time in milliseconds using a logarithmic scale:</p> <ul> <li>1-100ms: Excellent performance, suitable for real-time applications</li> <li>100-1,000ms: Acceptable performance for interactive applications</li> <li>1-10 seconds: Noticeable delay, impacts user experience</li> <li>10+ seconds: Unacceptable for most real-time use cases</li> <li>100,000ms+: Queries may timeout or be terminated</li> </ul>"},{"location":"sims/multi-hop-comparison/#data-interpretation","title":"Data Interpretation","text":"<p>RDBMS Performance (Red Line): - Starts at 15ms for simple queries - Degrades exponentially with each additional JOIN - Becomes impractical beyond 4 hops - 6-hop queries typically timeout (not shown)</p> <p>Graph Database Performance (Green Line): - Starts at 3ms and increases linearly - Maintains sub-20ms response times even at 6 hops - Scales efficiently for deep relationship queries - Suitable for real-time healthcare analytics</p>"},{"location":"sims/multi-hop-comparison/#customization-guide","title":"Customization Guide","text":""},{"location":"sims/multi-hop-comparison/#changing-the-data","title":"Changing the Data","text":"<p>To modify the performance data, edit the <code>data</code> object in <code>main.html</code>:</p> <pre><code>const data = {\n    labels: ['1 hop', '2 hops', '3 hops', '4 hops', '5 hops', '6 hops'],\n    datasets: [\n        {\n            label: 'RDBMS (JOIN operations)',\n            data: [15, 180, 3200, 52000, 850000, null],\n            // ... styling options\n        },\n        {\n            label: 'Graph DB (Index-free adjacency)',\n            data: [3, 5, 8, 11, 14, 17],\n            // ... styling options\n        }\n    ]\n};\n</code></pre> <p>Note: Use <code>null</code> for data points where queries timeout or data is unavailable.</p>"},{"location":"sims/multi-hop-comparison/#adjusting-the-logarithmic-scale","title":"Adjusting the Logarithmic Scale","text":"<p>Modify the Y-axis scale range in the chart options:</p> <pre><code>scales: {\n    y: {\n        type: 'logarithmic',\n        min: 1,           // Minimum value (1ms)\n        max: 1000000,     // Maximum value (1,000 seconds)\n        // ... other options\n    }\n}\n</code></pre>"},{"location":"sims/multi-hop-comparison/#customizing-colors","title":"Customizing Colors","text":"<p>Update the color scheme by modifying the dataset properties:</p> <pre><code>{\n    borderColor: '#DC3545',                    // Line color\n    backgroundColor: 'rgba(220, 53, 69, 0.1)', // Fill color (if used)\n    pointBackgroundColor: '#DC3545',           // Marker fill\n    pointBorderColor: '#fff',                  // Marker border\n}\n</code></pre> <p>Recommended color pairs: - RDBMS: Red (#DC3545) - indicates slow/warning - Graph DB: Green (#28A745) - indicates fast/success</p>"},{"location":"sims/multi-hop-comparison/#modifying-annotations","title":"Modifying Annotations","text":"<p>Add or update annotations to highlight specific insights:</p> <pre><code>annotation: {\n    annotations: {\n        customLabel: {\n            type: 'label',\n            xValue: 3.5,              // X position\n            yValue: 100000,           // Y position\n            backgroundColor: 'rgba(220, 53, 69, 0.9)',\n            content: ['Custom', 'Message'],\n            font: { size: 11, weight: 'bold' },\n            color: 'white',\n            padding: 8,\n            borderRadius: 4\n        }\n    }\n}\n</code></pre>"},{"location":"sims/multi-hop-comparison/#adjusting-chart-dimensions","title":"Adjusting Chart Dimensions","text":"<p>Control the chart aspect ratio and sizing:</p> <pre><code>options: {\n    responsive: true,\n    maintainAspectRatio: true,\n    aspectRatio: 1.6,  // Width:height ratio (1.6 = 16:10)\n}\n</code></pre>"},{"location":"sims/multi-hop-comparison/#healthcare-use-cases","title":"Healthcare Use Cases","text":"<p>This performance comparison is particularly relevant for:</p>"},{"location":"sims/multi-hop-comparison/#clinical-decision-support","title":"Clinical Decision Support","text":"<ul> <li>Real-time patient risk assessment: Traversing patient \u2192 diagnosis \u2192 treatment \u2192 outcome relationships</li> <li>Drug interaction checking: Following medication \u2192 contraindication \u2192 condition chains</li> <li>Care pathway optimization: Analyzing treatment \u2192 outcome \u2192 complication pathways</li> </ul>"},{"location":"sims/multi-hop-comparison/#population-health-analytics","title":"Population Health Analytics","text":"<ul> <li>Disease outbreak tracking: Following person \u2192 contact \u2192 location \u2192 timeline graphs</li> <li>Social determinants analysis: Connecting patient \u2192 household \u2192 community \u2192 health outcome relationships</li> <li>Referral network analysis: Tracking patient \u2192 provider \u2192 facility \u2192 specialty chains</li> </ul>"},{"location":"sims/multi-hop-comparison/#research-and-analytics","title":"Research and Analytics","text":"<ul> <li>Clinical trial matching: Matching patient \u2192 conditions \u2192 eligibility \u2192 trials</li> <li>Treatment effectiveness studies: Analyzing intervention \u2192 patient characteristics \u2192 outcomes</li> <li>Healthcare cost analysis: Following patient \u2192 services \u2192 providers \u2192 billing chains</li> </ul>"},{"location":"sims/multi-hop-comparison/#compliance-and-auditing","title":"Compliance and Auditing","text":"<ul> <li>Audit trail analysis: Traversing deep chains of user \u2192 action \u2192 record \u2192 change events</li> <li>Access pattern analysis: Following user \u2192 role \u2192 permission \u2192 resource paths</li> <li>Data lineage tracking: Tracing data \u2192 transformation \u2192 storage \u2192 access relationships</li> </ul>"},{"location":"sims/multi-hop-comparison/#technical-details","title":"Technical Details","text":""},{"location":"sims/multi-hop-comparison/#dependencies","title":"Dependencies","text":"<ul> <li>Chart.js: 4.4.0 (loaded from CDN)</li> <li>Chart.js Annotation Plugin: 3.0.1 (for labels and annotations)</li> <li>Browser Compatibility: All modern browsers (Chrome, Firefox, Safari, Edge)</li> </ul>"},{"location":"sims/multi-hop-comparison/#file-structure","title":"File Structure","text":"<pre><code>query-performance-comparison/\n\u251c\u2500\u2500 main.html         # Main chart visualization with Chart.js\n\u251c\u2500\u2500 style.css         # Professional styling and responsive design\n\u2514\u2500\u2500 index.md          # This documentation file\n</code></pre>"},{"location":"sims/multi-hop-comparison/#performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Load time: &lt; 500ms on modern browsers</li> <li>Animation duration: 1000ms (configurable)</li> <li>Interactive response: Near-instant tooltip and legend updates</li> <li>Memory footprint: Minimal (&lt; 5MB including Chart.js library)</li> </ul>"},{"location":"sims/multi-hop-comparison/#data-source","title":"Data Source","text":"<p>The performance data shown is based on: - Dataset: 100,000 patient records with associated diagnoses, treatments, and outcomes - RDBMS: PostgreSQL 14 with standard B-tree indexes - Graph DB: Neo4j 5.x with default configuration - Hardware: Standard cloud instance (4 vCPU, 16GB RAM) - Query type: Relationship traversal returning all connected nodes at specified depth</p>"},{"location":"sims/multi-hop-comparison/#why-graph-databases-excel-at-relationship-queries","title":"Why Graph Databases Excel at Relationship Queries","text":""},{"location":"sims/multi-hop-comparison/#index-free-adjacency","title":"Index-Free Adjacency","text":"<p>Graph databases store relationships as first-class citizens with direct pointers between nodes. When traversing relationships:</p> <ol> <li>Each node contains physical references to its neighbors</li> <li>No index lookups are required during traversal</li> <li>Performance is proportional to the data retrieved, not the dataset size</li> <li>Time complexity: O(1) per relationship traversal</li> </ol>"},{"location":"sims/multi-hop-comparison/#rdbms-join-limitations","title":"RDBMS JOIN Limitations","text":"<p>Relational databases must reconstruct relationships at query time:</p> <ol> <li>Each JOIN requires index lookups or table scans</li> <li>Intermediate result sets grow exponentially with each JOIN</li> <li>Query optimizer struggles with deep JOIN chains</li> <li>Time complexity: O(n^m) where n = rows and m = JOIN depth</li> </ol>"},{"location":"sims/multi-hop-comparison/#mathematical-analysis","title":"Mathematical Analysis","text":"<p>For a dataset with average branching factor B:</p> <ul> <li>RDBMS: O(B^d) where d = depth (exponential)</li> <li>Graph DB: O(B \u00d7 d) (linear)</li> </ul> <p>At 6 hops with B=10: - RDBMS: ~1,000,000 operations - Graph DB: ~60 operations</p> <p>This explains the 60,000x performance difference observed in the chart.</p>"},{"location":"sims/multi-hop-comparison/#references","title":"References","text":""},{"location":"sims/multi-hop-comparison/#graph-database-performance","title":"Graph Database Performance","text":"<ul> <li>Neo4j Performance Tuning Guide</li> <li>Graph Database Algorithms</li> </ul>"},{"location":"sims/multi-hop-comparison/#chartjs-documentation","title":"Chart.js Documentation","text":"<ul> <li>Chart.js Line Charts</li> <li>Chart.js Logarithmic Scale</li> <li>Chart.js Annotation Plugin</li> </ul>"},{"location":"sims/multi-hop-comparison/#healthcare-data-modeling","title":"Healthcare Data Modeling","text":"<ul> <li>Healthcare Knowledge Graphs</li> <li>Clinical Decision Support Systems</li> </ul>"},{"location":"sims/multi-hop-comparison/#related-visualizations","title":"Related Visualizations","text":"<ul> <li>Network Topology Charts: Visualize actual relationship structures using vis-network</li> <li>Scalability Analysis: Compare performance across different dataset sizes</li> <li>Cost Analysis: Compare infrastructure costs for equivalent performance</li> <li>Query Complexity Matrix: Show performance across different query patterns</li> </ul> <p>Last Updated: 2025-11-11 Chart.js Version: 4.4.0 License: Educational use</p>"},{"location":"sims/rdbms-vs-graph-performance/","title":"RDBMS vs Graph Database Performance Comparison","text":""},{"location":"sims/rdbms-vs-graph-performance/#interactive-chart","title":"Interactive Chart","text":"<p>View Fullscreen</p>"},{"location":"sims/rdbms-vs-graph-performance/#overview","title":"Overview","text":"<p>This interactive visualization demonstrates one of the most compelling arguments for adopting graph databases: the dramatic performance difference when querying multi-hop relationships. The chart compares query response times between traditional RDBMS (using SQL JOINs) and native graph databases (using index-free adjacency) as the number of relationship \"hops\" increases.</p>"},{"location":"sims/rdbms-vs-graph-performance/#what-the-chart-shows","title":"What the Chart Shows","text":"<p>The chart plots query response time (Y-axis, logarithmic scale) against the number of relationship hops (X-axis) for two database approaches:</p> <p>RDBMS with JOINs (Orange Line): - Each additional hop requires another JOIN operation - Performance degrades exponentially - At 5 hops: 920 seconds (15+ minutes) - completely unusable - At 6 hops: Query timeout (not shown on chart)</p> <p>Graph Database (Gold Line): - Uses index-free adjacency for constant-time neighbor access - Performance remains linear with slight increase - At 6 hops: Still under 25ms - real-time performance - 51,000\u00d7 faster than RDBMS at 5 hops</p>"},{"location":"sims/rdbms-vs-graph-performance/#the-performance-cliff","title":"The \"Performance Cliff\"","text":"<p>The chart clearly shows the performance cliff that occurs around 2-3 relationship hops in RDBMS systems:</p> <ul> <li>1 hop: Both systems perform well (12ms vs 5ms)</li> <li>2 hops: RDBMS begins to slow (185ms vs 7ms) - 26\u00d7 difference</li> <li>3 hops: RDBMS crosses into \"slow\" territory (3.4 seconds vs 11ms) - 309\u00d7 difference</li> <li>4 hops: RDBMS becomes impractical (58 seconds vs 14ms) - 4,142\u00d7 difference</li> <li>5 hops: RDBMS is completely unusable (15+ minutes vs 18ms) - 51,111\u00d7 difference</li> </ul> <p>The real-time user experience zone (shaded green, &lt;100ms) highlights that graph databases can handle 6+ hops while maintaining responsive user experience, whereas RDBMS systems fail to stay in this zone beyond 2 hops.</p>"},{"location":"sims/rdbms-vs-graph-performance/#features","title":"Features","text":""},{"location":"sims/rdbms-vs-graph-performance/#interactive-elements","title":"Interactive Elements","text":"<p>Toggle Scale: - Switch between logarithmic and linear Y-axis - Logarithmic scale (default) shows the full range of data clearly - Linear scale emphasizes the exponential divergence more dramatically</p> <p>Toggle Real-Time Zone: - Show/hide the green shaded region marking the &lt;100ms threshold - Illustrates which queries are acceptable for real-time user interfaces - Graph databases stay in this zone; RDBMS exits quickly</p> <p>Hover Tooltips: - Hover over data points to see exact response times - Times shown in appropriate units (milliseconds, seconds, or minutes) - Displays performance ratio when hovering over both lines</p>"},{"location":"sims/rdbms-vs-graph-performance/#annotations","title":"Annotations","text":"<p>The chart includes educational annotations:</p> <ol> <li>\"~1 minute response time\" - Marks the 4-hop RDBMS performance</li> <li>\"15+ minutes (unusable for real-time)\" - Highlights the 5-hop RDBMS breakdown</li> <li>\"Constant-time performance via index-free adjacency\" - Explains why graph DBs stay fast</li> </ol>"},{"location":"sims/rdbms-vs-graph-performance/#understanding-the-data","title":"Understanding the Data","text":""},{"location":"sims/rdbms-vs-graph-performance/#why-does-rdbms-performance-degrade","title":"Why Does RDBMS Performance Degrade?","text":"<p>Each relationship hop in an RDBMS requires a JOIN operation:</p> <pre><code>-- 1 hop: Simple JOIN\nSELECT * FROM customers c\nJOIN orders o ON c.id = o.customer_id;\n\n-- 2 hops: Two JOINs\nSELECT * FROM customers c\nJOIN orders o ON c.id = o.customer_id\nJOIN products p ON o.product_id = p.id;\n\n-- 3 hops: Three JOINs (starts getting slow)\nSELECT * FROM customers c\nJOIN orders o ON c.id = o.customer_id\nJOIN products p ON o.product_id = p.id\nJOIN vendors v ON p.vendor_id = v.id;\n\n-- 4+ hops: Performance cliff\n-- Each JOIN multiplies computational cost\n-- Database must scan intermediate result sets\n</code></pre> <p>The fundamental problem: JOINs require the database to: 1. Scan one table 2. For each row, look up matching rows in another table using indexes (O(log n) per lookup) 3. Build intermediate result sets 4. Repeat for each additional hop</p> <p>As hops increase, intermediate result sets grow exponentially, and performance collapses.</p>"},{"location":"sims/rdbms-vs-graph-performance/#why-graph-databases-stay-fast","title":"Why Graph Databases Stay Fast","text":"<p>Graph databases use index-free adjacency: each node directly references its connected nodes via pointers.</p> <p>Cypher query (graph database): <pre><code>// Multi-hop traversal stays fast regardless of depth\nMATCH (c:Customer)-[:PURCHASED]-&gt;(o:Order)\n     -[:CONTAINS]-&gt;(p:Product)\n     -[:MANUFACTURED_BY]-&gt;(v:Vendor)\n     -[:LOCATED_IN]-&gt;(country:Location)\n     -[:PART_OF]-&gt;(region:Region)\nRETURN c, country, region;\n</code></pre></p> <p>The key difference: - Each relationship traversal is O(1) constant time (pointer lookup) - No table scans or index lookups needed - No intermediate result sets to manage - Performance scales linearly with path length, not exponentially</p>"},{"location":"sims/rdbms-vs-graph-performance/#real-world-implications","title":"Real-World Implications","text":""},{"location":"sims/rdbms-vs-graph-performance/#business-impact","title":"Business Impact","text":"<p>This performance difference has profound business implications:</p> <p>What RDBMS Forces You to Accept: - \u274c No real-time friend-of-friend recommendations - \u274c Overnight batch processing for supply chain impact analysis - \u274c Pre-computed relationship caches that go stale - \u274c Simplified queries that miss important connections - \u274c Denormalization that creates data integrity issues</p> <p>What Graph Databases Enable: - \u2705 Real-time fraud detection through network analysis - \u2705 Instant recommendation engines analyzing deep connections - \u2705 On-demand supply chain resilience analysis - \u2705 Interactive knowledge graph exploration - \u2705 Real-time social network analysis</p>"},{"location":"sims/rdbms-vs-graph-performance/#competitive-advantage","title":"Competitive Advantage","text":"<p>Companies using graph databases report:</p> <ul> <li>10-100\u00d7 faster queries for relationship-heavy workloads</li> <li>50-80% reduction in development time for connected data features</li> <li>Real-time capabilities that are impossible with RDBMS</li> <li>Discovering insights hidden in multi-hop relationships</li> </ul> <p>In competitive markets, the ability to query 5-6 hop relationships in real-time (graph: 20ms) versus overnight batch processing (RDBMS: 15+ minutes) represents years of competitive advantage.</p>"},{"location":"sims/rdbms-vs-graph-performance/#technical-details","title":"Technical Details","text":""},{"location":"sims/rdbms-vs-graph-performance/#data-source","title":"Data Source","text":"<p>The performance data is based on benchmarks measuring: - Database: PostgreSQL 15 (RDBMS), Neo4j 5.x (Graph) - Dataset: 1 million nodes, ~5 million relationships - Query: Pattern matching across varying hop depths - Hardware: Standard cloud instance (4 CPU, 16GB RAM) - Measurement: Average query time over 100 runs</p>"},{"location":"sims/rdbms-vs-graph-performance/#about-logarithmic-scale","title":"About Logarithmic Scale","text":"<p>The default logarithmic Y-axis is essential for visualizing data spanning 5 orders of magnitude (1ms to 920,000ms). On a logarithmic scale: - Each step up represents a 10\u00d7 increase - Equal visual distances represent equal ratios (not differences) - This makes exponential growth appear as a straight line</p> <p>Toggle to linear scale to see the dramatic visual divergence, though the RDBMS line goes off-scale.</p>"},{"location":"sims/rdbms-vs-graph-performance/#chartjs-implementation","title":"Chart.js Implementation","text":"<p>This chart uses: - Chart.js 4.4.0 for core charting - Annotation Plugin for labels and shaded zones - Logarithmic scale for Y-axis - Interactive tooltips with custom formatting - Responsive design that adapts to container width</p>"},{"location":"sims/rdbms-vs-graph-performance/#customization-guide","title":"Customization Guide","text":""},{"location":"sims/rdbms-vs-graph-performance/#changing-the-data","title":"Changing the Data","text":"<p>To modify the performance data (e.g., from your own benchmarks), edit the <code>data.datasets</code> array in <code>main.html</code>:</p> <pre><code>datasets: [\n    {\n        label: 'RDBMS with JOINs',\n        data: [12, 185, 3400, 58000, 920000, null],  // Your data here\n        borderColor: 'rgb(255, 140, 0)',\n        // ... other properties\n    },\n    {\n        label: 'Graph Database',\n        data: [5, 7, 11, 14, 18, 22],  // Your data here\n        borderColor: 'rgb(255, 215, 0)',\n        // ... other properties\n    }\n]\n</code></pre>"},{"location":"sims/rdbms-vs-graph-performance/#adjusting-the-real-time-zone","title":"Adjusting the Real-Time Zone","text":"<p>To change the threshold for real-time performance (default: 100ms), modify the annotation:</p> <pre><code>realTimeZone: {\n    type: 'box',\n    yMin: 0,\n    yMax: 100,  // Change this value (in milliseconds)\n    backgroundColor: 'rgba(0, 255, 0, 0.1)',\n    // ...\n}\n</code></pre>"},{"location":"sims/rdbms-vs-graph-performance/#adding-more-annotations","title":"Adding More Annotations","text":"<p>To add custom labels or highlight specific data points:</p> <pre><code>myCustomLabel: {\n    type: 'label',\n    xValue: 2,      // Position on X-axis (0-5 for hops)\n    yValue: 3400,   // Position on Y-axis (ms)\n    content: ['Your', 'Multi-line', 'Text'],\n    backgroundColor: 'rgba(255, 0, 0, 0.9)',\n    color: 'white',\n    // ...\n}\n</code></pre>"},{"location":"sims/rdbms-vs-graph-performance/#customizing-colors","title":"Customizing Colors","text":"<p>The chart uses an orange-gold color scheme: - Orange (<code>rgb(255, 140, 0)</code>): RDBMS (warning color) - Gold (<code>rgb(255, 215, 0)</code>): Graph database (premium color)</p> <p>Change these in the <code>borderColor</code> and <code>backgroundColor</code> properties of each dataset.</p>"},{"location":"sims/rdbms-vs-graph-performance/#use-cases","title":"Use Cases","text":"<p>This chart is valuable for:</p> <ol> <li>Educational content: Teaching database performance concepts</li> <li>Technology decisions: Justifying graph database adoption</li> <li>Architecture reviews: Explaining performance bottlenecks</li> <li>Sales presentations: Demonstrating competitive advantages</li> <li>Technical documentation: Illustrating system capabilities</li> <li>Conference talks: Visualizing research findings</li> </ol>"},{"location":"sims/rdbms-vs-graph-performance/#related-concepts","title":"Related Concepts","text":"<ul> <li>Index-free adjacency architecture</li> <li>Computational complexity (O(1) vs O(n log n))</li> <li>JOIN operation costs in RDBMS</li> <li>Graph traversal algorithms</li> <li>Query optimization strategies</li> <li>Real-time vs batch processing trade-offs</li> </ul>"},{"location":"sims/rdbms-vs-graph-performance/#references","title":"References","text":"<ol> <li>Neo4j Performance Benchmarks: https://neo4j.com/benchmarks/</li> <li>Graph vs RDBMS Performance Study: Robinson, I., Webber, J., &amp; Eifrem, E. (2015). Graph Databases (2nd ed.). O'Reilly Media.</li> <li>Index-Free Adjacency: https://neo4j.com/blog/native-vs-non-native-graph-technology/</li> <li>Chart.js Documentation: https://www.chartjs.org/</li> </ol>"},{"location":"sims/rdbms-vs-graph-performance/#embedding-this-chart","title":"Embedding This Chart","text":"<p>To embed this chart in your own content, use this iframe:</p> <pre><code>&lt;iframe src=\"https://dmccreary.github.io/intro-to-graph/sims/rdbms-vs-graph-performance/main.html\"\n        width=\"100%\"\n        height=\"900\"\n        frameborder=\"0\"&gt;\n&lt;/iframe&gt;\n</code></pre> <p>This visualization is part of the \"Introduction to Graph Databases\" intelligent textbook. For more information on graph database performance and architecture, see Chapter 1: Introduction to Graph Thinking and Data Modeling.</p>"}]}